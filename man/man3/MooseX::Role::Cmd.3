.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Role::Cmd 3"
.TH MooseX::Role::Cmd 3 "2010-12-07" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Role::Cmd \- Wrap system command binaries the Moose way
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Create your command wrapper:
.PP
.Vb 1
\&    package Cmd::Perl;
\&
\&    use Moose;
\&
\&    with \*(AqMooseX::Role::Cmd\*(Aq;
\&
\&    has \*(Aqe\*(Aq => (isa => \*(AqStr\*(Aq, is => \*(Aqrw\*(Aq);
\&
\&    # other perl switches here...
\&
\&    1;
.Ve
.PP
Use it somewhere else:
.PP
.Vb 1
\&    use Cmd::Perl;
\&
\&    my $perl = Cmd::Perl\->new(e => q{\*(Aqprint join ", ", @ARGV\*(Aq});
\&
\&    print $perl\->run(qw/foo bar baz/);
\&
\&    # prints the STDOUT captured from running:
\&    # perl \-e \*(Aqprint join ", ", @ARGV\*(Aq foo bar baz
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
MooseX::Role::Cmd is a Moose role intended to ease the task of building
command-line wrapper modules. It automatically maps Moose objects into
command strings which are passed to IPC::Cmd.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.ie n .SS "$cmd\->bin_name"
.el .SS "\f(CW$cmd\fP\->bin_name"
.IX Subsection "$cmd->bin_name"
Sets the binary executable name for the command you want to run. Defaults
the to last part of the class name.
.ie n .SS "$cmd\->stdout"
.el .SS "\f(CW$cmd\fP\->stdout"
.IX Subsection "$cmd->stdout"
Returns the \s-1STDOUT\s0 buffer captured after running the command.
.ie n .SS "$cmd\->stderr"
.el .SS "\f(CW$cmd\fP\->stderr"
.IX Subsection "$cmd->stderr"
Returns the \s-1STDERR\s0 buffer captured after running the command.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$bin_name = $cmd\->build_bin_name"
.el .SS "\f(CW$bin_name\fP = \f(CW$cmd\fP\->build_bin_name"
.IX Subsection "$bin_name = $cmd->build_bin_name"
Builds the default string for the command name based on the class name.
.ie n .SS "@stdout = $cmd\->run(@args);"
.el .SS "\f(CW@stdout\fP = \f(CW$cmd\fP\->run(@args);"
.IX Subsection "@stdout = $cmd->run(@args);"
Builds the command string and runs it based on the objects current attribute
settings. This will treat all the attributes defined in your class as flags
to be passed to the command.
.PP
\&\fB\s-1NOTE:\s0\fR All quoting issues are left to be solved by the user.
.SS "cmd_args"
.IX Subsection "cmd_args"
Returns a list of the computed arguments that will be added to the command
.SH "ADDITIONAL INFORMATION"
.IX Header "ADDITIONAL INFORMATION"
.SS "Setting the Executable"
.IX Subsection "Setting the Executable"
By default the name of the binary executable is taken from the last part of the class name
(in lower case). The path is set during the run method by scanning through your current
\&\s-1PATH\s0 for the given executable (see also the 'can_run' function from IPC::Cmd)
.PP
.Vb 3
\&    package MyApp::Commands::Scanner;
\&    use Moose;
\&    with \*(AqMooseX::Role::Cmd\*(Aq;
\&
\&    $cmd = MyApp::Commands::Scanner\->new();
\&    $cmd\->bin_name
\&    # /path/to/scanner
.Ve
.PP
If this default behaviour doesn't suit your application then you can override the build_bin_name
subroutine to explicitly set the executable name
.PP
.Vb 2
\&    sub build_bin_name { \*(Aqscanner.exe\*(Aq }
\&    # /path/to/scanner.exe
.Ve
.PP
Or you could explicitly set the path with
.PP
.Vb 2
\&    sub build_bin_name { \*(Aq/only/use/this/path/scanner.exe\*(Aq }
\&    # /only/use/this/path/scanner.exe
.Ve
.SS "How attributes are mapped to parameters"
.IX Subsection "How attributes are mapped to parameters"
The attributes of the consuming package map directly to the parameters passed
to the executable. There are a few things to note about the default behaviour
governing the way these attributes are mapped.
.PP
.Vb 8
\&    Attribute           Default Behaviour (@ARGV)
\&    \-\-\-\-\-\-\-\-\-           \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    single char         prefix attr name with \*(Aq\-\*(Aq
\&    multiple char       prefix attr name with \*(Aq\-\-\*(Aq
\&    boolean             treat attr as flag (no value)
\&    non\-boolean         treat attr as parameter (with value)
\&    value=undef         ignore attr
\&    name=_name          ignore attr
.Ve
.PP
These points are illustrated in the following example:
.PP
.Vb 3
\&    package MyApp::Commands::Scanner;
\&    use Moose;
\&    with \*(AqMooseX::Role::Cmd\*(Aq;
\&
\&    has \*(Aqi\*(Aq       => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,  default => \*(Aqinput.txt\*(Aq );
\&    has \*(Aqout\*(Aq     => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&    has \*(Aqverbose\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqBool\*(Aq, default => 1 );
\&    has \*(Aqlevel\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq );
\&    has \*(Aqoption\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&
\&    has \*(Aq_internal\*(Aq => ( is => \*(Aqro\*(Aq, isa => Str, reader => internal, default => \*(Aqfoo\*(Aq );
\&    # attribute names starting with \*(Aq_\*(Aq are not included
\&
\&    $scanner = MyApp::Commands::Scanner\->new( output => \*(Aq/tmp/scanner.log\*(Aq, level => 5 );
\&
\&    $scanner\->run;
\&    # /path/to/scanner \-i input.txt \-\-out /tmp/scanner.log \-\-verbose \-\-level 5
.Ve
.SS "Changing names of parameters"
.IX Subsection "Changing names of parameters"
It's possible that the parameters your system command expects do not adhere to this
naming scheme. In this case you can use the 'CmdOpt' trait which allows you to
specify exactly how you want the parameter to appear on the command line.
.PP
.Vb 2
\&    has \*(Aqoption\*(Aq => ( isa           => \*(AqBool\*(Aq );
\&    # \-\-option
.Ve
.PP
\fIcmdopt_prefix\fR
.IX Subsection "cmdopt_prefix"
.PP
This lets you override the prefix used for the option (for example to use the short
form of multi-character options).
.PP
.Vb 5
\&    has \*(Aqoption\*(Aq => ( traits        => [ \*(AqCmdOpt\*(Aq ],
\&                      isa           => \*(AqBool\*(Aq,
\&                      cmdopt_prefix => \*(Aq\-\*(Aq
\&                    );
\&    # \-option
.Ve
.PP
\fIcmdopt_name\fR
.IX Subsection "cmdopt_name"
.PP
This lets you completely override the option name with whatever string you want
.PP
.Vb 5
\&    has \*(Aqoption\*(Aq => ( traits        => [ \*(AqCmdOpt\*(Aq ],
\&                      isa           => \*(AqBool\*(Aq,
\&                      cmdopt_name   => \*(Aq+foo\*(Aq
\&                    );
\&    # +foo
.Ve
.PP
\fIcmdopt_env\fR
.IX Subsection "cmdopt_env"
.PP
This will set an environment variable with the attribute name/value rather than pass
it along as a command line param
.PP
.Vb 5
\&    has \*(Aqhome_dir\*(Aq => ( traits      => [ \*(AqCmdOpt\*(Aq ],
\&                        isa         => \*(AqStr\*(Aq,
\&                        cmdopt_env  => \*(AqAPP_HOME\*(Aq
\&                        default     => \*(Aq/my/app/home\*(Aq
\&                    );
\&
\&    # ENV{APP_HOME} = /my/app/home
.Ve
.PP
See MooseX::Role::Cmd::Meta::Attribute::Trait
.SH "PRIVATE METHODS"
.IX Header "PRIVATE METHODS"
.SS "_attr_to_cmd_options"
.IX Subsection "_attr_to_cmd_options"
Returns an array (or array reference) of command options that correspond
to the given attribute name.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eden Cardim <edencardim@gmail.com>
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software, you can redistribute it and/or modify it under
the same terms as Perl itself.
