.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POE::Resource::Statistics 3"
.TH POE::Resource::Statistics 3 "2010-11-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Resource::Statistics \-\- experimental run\-time statistics for POE
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  my %stats = $poe_kernel\->stat_getdata;
\&  printf "Idle = %3.2f\en", 100*$stats{avg_idle_seconds}/$stats{interval};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Resource::Statistics is a mix-in class for POE::Kernel.  It
provides features for gathering run-time statistics about POE::Kernel
and the applications that use it.
.PP
Statistics gathering is enabled with the \s-1TRACE_STATISTICS\s0 constant.
There is no run-time performance penalty when tracing is disabled.
.PP
Statistics are totaled every 30 seconds, and a rolling average is
maintained for the last two minutes.  The data may be retrieved at any
time with the \fIstat_getdata()\fR method.  Statistics will also be
displayed on the console shortly before POE::Kernel's \fIrun()\fR returns.
.PP
The \fItime()\fR function is used to gather statistics over time.  If
Time::HiRes is available, it will be used automatically.  Otherwise
time is measured in whole seconds, and the resulting rounding errors
will make the statistics much less useful.
.PP
Run-time statistics gathering was added to \s-1POE\s0 0.28.  It is considered
\&\fBhighly experimental\fR.  Please be advised that the statistics it
gathers are quite likely wrong.  They may in fact be useless.  The
reader is invited to investigate and improve the module's
methodologies.
.SH "Gathered Statistics"
.IX Header "Gathered Statistics"
\&\fIstat_getdata()\fR returns a hashref with a small number of accumulated
values.  For each accumulator, there will be a corresponding field
prefixed \*(L"avg_\*(R" which is the rolling average for that accumulator.
.SS "blocked"
.IX Subsection "blocked"
\&\f(CW\*(C`blocked\*(C'\fR contains the number of events (both user and kernel) which
were delayed due to a user event running for too long.  On conclusion
of the program, \s-1POE\s0 will display the blocked count.
.PP
In theory, one can compare \f(CW\*(C`blocked\*(C'\fR with \f(CW\*(C`user_events\*(C'\fR to determine
how much lag is produced by user code.  \f(CW\*(C`blocked\*(C'\fR should be as low as
possible to ensure minimum user-generated event lag.
.PP
In practice, \f(CW\*(C`blocked\*(C'\fR is often near or above \f(CW\*(C`user_events\*(C'\fR.  Events
that are even the slightest bit late count as being \*(L"blocked\*(R".  See
\&\f(CW\*(C`blocked_seconds\*(C'\fR for a potentially more useful metric.
.SS "blocked_seconds"
.IX Subsection "blocked_seconds"
\&\f(CW\*(C`blocked_seconds\*(C'\fR contains the total number of seconds that events
waited in the queue beyond their nominal dispatch times.  The average
(\f(CW\*(C`avg_blocked_seconds\*(C'\fR) is generally more useful.
.SS "idle_seconds"
.IX Subsection "idle_seconds"
\&\f(CW\*(C`idle_seconds\*(C'\fR is the amount of time that \s-1POE\s0 spent doing nothing at
all.  Typically this time is spent waiting for I/O or timers rather
than dispatching events.
.SS "interval"
.IX Subsection "interval"
\&\f(CW\*(C`interval\*(C'\fR is the average interval over which the statistics counters
are recorded.  This will typically be 30 seconds, but it can be more
if long-running user events prevent statistics from being gathered on
time.  \f(CW\*(C`interval\*(C'\fR may also be less for programs that finish in under
half a minute.
.PP
\&\f(CW\*(C`avg_interval\*(C'\fR may often be lower, as the very last measurement taken
before POE::Kernel's \fIrun()\fR returns will almost always have an
\&\f(CW\*(C`interval\*(C'\fR less than 30 seconds.
.SS "total_duration"
.IX Subsection "total_duration"
\&\f(CW\*(C`total_duration\*(C'\fR contains the total time over which the average was
calculated.  The \*(L"avg_\*(R" accumulators are averaged over a 2\-minute
interval.  \f(CW\*(C`total_duration\*(C'\fR may vary from 120 seconds due to the same
reasons as described in \*(L"interval\*(R".
.SS "user_events"
.IX Subsection "user_events"
\&\f(CW\*(C`user_events\*(C'\fR contains the number of events that have been dispatched
to user code.  \*(L"User\*(R" events do not include \s-1POE\s0's internal events,
although it will include events dispatched on behalf of wheels.
.PP
Shortly before POE::Kernel's \fIrun()\fR returns, a \f(CW\*(C`user_load\*(C'\fR value will
be computed showing the average number of user events that have been
dispatched per second.  A very active web server should have a high
\&\f(CW\*(C`user_load\*(C'\fR value.  The higher the user load, the more important it
is to have small \f(CW\*(C`blocked\*(C'\fR and \f(CW\*(C`blocked_seconds\*(C'\fR values.
.SS "user_seconds"
.IX Subsection "user_seconds"
\&\f(CW\*(C`user_seconds\*(C'\fR is the time that was spent handling user events,
including those handled by wheels.  \f(CW\*(C`user_seconds\*(C'\fR + \f(CW\*(C`idle_seconds\*(C'\fR
should typically add up to \f(CW\*(C`total_duration\*(C'\fR.  Any difference is
unaccounted time in \s-1POE\s0, and indicates a flaw in the statistics
gathering methodology.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See \*(L"\s-1TRACE_STATISTICS\s0\*(R" in POE::Kernel for instructions to enable
statistics gathering.
.SH "BUGS"
.IX Header "BUGS"
Statistics may be highly inaccurate.  This feature is \fBhighly
experimental\fR and may change significantly over time.
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
Contributed by Nick Williams <Nick.Williams@morganstanley.com>.
.PP
Please see \s-1POE\s0 for more information about authors and contributors.
