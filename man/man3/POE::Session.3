.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POE::Session 3"
.TH POE::Session 3 "2010-11-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Session \- a generic event\-driven task
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use POE; # auto\-includes POE::Kernel and POE::Session
\&
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub { $_[KERNEL]\->yield("next") },
\&      next   => sub {
\&        print "tick...\en";
\&        $_[KERNEL]\->delay(next => 1);
\&      },
\&    },
\&  );
\&
\&  POE::Kernel\->run();
\&  exit;
.Ve
.PP
POE::Session can also dispatch to object and class methods through
\&\*(L"object_states\*(R" and \*(L"package_states\*(R" callbacks.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Session and its subclasses translate events from POE::Kernel's
generic dispatcher into the particular calling conventions suitable for
application code.  In design pattern parlance, POE::Session classes
are adapters between POE::Kernel and application code.
.PP
The sessions that POE::Kernel manages are more
like generic task structures.  Unfortunately these two disparate
concepts have virtually identical names.
.SS "A note on nomenclature"
.IX Subsection "A note on nomenclature"
This documentation will refer to event handlers as \*(L"states\*(R" in certain
unavoidable situations.  Sessions were originally meant to be
event-driven state machines, but their purposes evolved over time.
Some of the legacy vocabulary lives on in the \s-1API\s0 for backward
compatibility, however.
.PP
Confusingly, \s-1POE::NFA\s0 is a class for implementing actual
event-driven state machines.  Its documentation uses \*(L"state\*(R" in the
proper sense.
.SH "USING POE::Session"
.IX Header "USING POE::Session"
POE::Session has two main purposes.  First, it maps event names to the
code that will handle them.  Second, it maps a consistent event
dispatch interface to those handlers.
.PP
Consider the \*(L"\s-1SYNOPSIS\s0\*(R" for example.  A POE::Session instance is
created with two \f(CW\*(C`inline_states\*(C'\fR, each mapping an event name
(\*(L"_start\*(R" and \*(L"next\*(R") to an inline subroutine.  POE::Session ensures
that \*(L"$_[\s-1KERNEL\s0]\*(R" and so on are meaningful within an event handler.
.PP
Event handlers may also be object or class methods, using
\&\*(L"object_states\*(R" and \*(L"package_states\*(R" respectively.  The \fIcreate()\fR
syntax is different than for \f(CW\*(C`inline_states\*(C'\fR, but the calling
convention is nearly identical.
.PP
Notice that the created POE::Session object has not been saved to a
variable.  The new POE::Session object gives itself to POE::Kernel,
which then manages it and all the resources it uses.
.PP
It's possible to keep references to new POE::Session objects, but it's
not usually necessary.  If an application is not careful about
cleaning up these references you will create circular references,
which will leak memory when POE::Kernel would normally destroy the
POE::Session object.  It is recommended that you keep the session's
\&\s-1ID\s0 instead.
.SS "POE::Session's Calling Convention"
.IX Subsection "POE::Session's Calling Convention"
The biggest syntactical hurdle most people have with \s-1POE\s0 is
POE::Session's unconventional calling convention.  For example:
.PP
.Vb 4
\&  sub handle_event {
\&    my ($kernel, $heap, $parameter) = @_[KERNEL, HEAP, ARG0];
\&    ...;
\&  }
.Ve
.PP
Or the use of \f(CW$_[KERNEL]\fR, \f(CW$_[HEAP]\fR and \f(CW$_[ARG0]\fR inline,
as is done in most examples.
.PP
What's going on here is rather basic.  Perl passes parameters into
subroutines or methods using the \f(CW@_\fR array.  \f(CW\*(C`KERNEL\*(C'\fR, \f(CW\*(C`HEAP\*(C'\fR,
\&\f(CW\*(C`ARG0\*(C'\fR and others are constants exported by POE::Session (which is
included for free when a program uses \s-1POE\s0).
.PP
So \f(CW$_[KERNEL]\fR is an event handler's KERNELth parameter.
\&\f(CW@_[HEAP, ARG0]\fR is a slice of \f(CW@_\fR containing the HEAPth and ARG0th
parameters.
.PP
While this looks odd, it's perfectly plain and legal Perl syntax.  \s-1POE\s0
uses it for a few reasons:
.IP "1." 4
In the common case, passing parameters in \f(CW@_\fR is faster than passing
hash or array references and then dereferencing them in the handler.
.IP "2." 4
Typos in hash-based parameter lists are either subtle run-time
errors or requires constant run-time checking.  Constants are either
known at compile time, or are clear compile-time errors.
.IP "3." 4
Referencing \f(CW@_\fR offsets by constants allows parameters to move
in the future without breaking application code.
.IP "4." 4
Most event handlers don't need all of \f(CW@_\fR.  Slices allow handlers to
use only the parameters they're interested in.
.SS "POE::Session Parameters"
.IX Subsection "POE::Session Parameters"
Event handlers receive most of their run-time context in up to nine
callback parameters.  POE::Kernel provides many of them.
.PP
\fI\f(CI$_\fI[\s-1OBJECT\s0]\fR
.IX Subsection "$_[OBJECT]"
.PP
\&\f(CW$_[OBJECT]\fR is \f(CW$self\fR for event handlers that are an object method.  It is
the class (package) name for class-based event handlers.  It is undef
for plain coderef callbacks, which have no special \f(CW$self\fR\-ish value.
.PP
\&\f(CW\*(C`OBJECT\*(C'\fR is always zero, since \f(CW$_[0]\fR is always \f(CW$self\fR or \f(CW$class\fR
in object and class methods.  Coderef handlers are called with
an \f(CW\*(C`undef\*(C'\fR placeholder in \f(CW$_[0]\fR so that the other offsets remain valid.
.PP
It's often useful for method-based event handlers to call other
methods in the same object.  \f(CW$_[OBJECT]\fR helps this happen.
.PP
.Vb 6
\&  sub ui_update_everything {
\&    my $self = $_[OBJECT];
\&    $self\->update_menu();
\&    $self\->update_main_window();
\&    $self\->update_status_line();
\&  }
.Ve
.PP
You may also use method inheritance.  Here we invoke
\&\f(CW$self\fR\->a_method(@_).  Since Perl's \f(CW\*(C`<\-\*(C'\fR>> operator unshifts \f(CW$self\fR
onto the beginning of \f(CW@_\fR, we must first shift a copy off to maintain
\&\s-1POE\s0's parameter offsets:
.PP
.Vb 5
\&  sub a_method {
\&    my $self = shift;
\&    $self\->SUPER::a_method( @_ );
\&    # ... more work ...
\&  }
.Ve
.PP
\fI\f(CI$_\fI[\s-1SESSION\s0]\fR
.IX Subsection "$_[SESSION]"
.PP
\&\f(CW$_[SESSION]\fR is a reference to the current session object.  This lets event
handlers access their session's methods.  Programs may also compare
\&\f(CW$_[SESSION]\fR to \f(CW$_[SENDER]\fR to verify that intra-session events did not
come from other sessions.
.PP
\&\f(CW$_[SESSION]\fR may also be used as the destination for intra-session
\&\fIpost()\fR and \fIcall()\fR.  \fIyield()\fR is marginally more convenient and
efficient than \f(CW\*(C`post($_[SESSION], ...)\*(C'\fR however.
.PP
It is bad form to access another session directly.  The recommended
approach is to manipulate a session through an event handler.
.PP
.Vb 10
\&  sub enable_trace {
\&    my $previous_trace = $_[SESSION]\->option( trace => 1 );
\&    my $id = $_[SESSION]\->ID;
\&    if ($previous_trace) {
\&      print "Session $id: dispatch trace is still on.\en";
\&    }
\&    else {
\&      print "Session $id: dispatch trace has been enabled.\en";
\&    }
\&  }
.Ve
.PP
\fI\f(CI$_\fI[\s-1KERNEL\s0]\fR
.IX Subsection "$_[KERNEL]"
.PP
The KERNELth parameter is always a reference to the application's
singleton POE::Kernel instance.  It is most often used to call
POE::Kernel methods from event handlers.
.PP
.Vb 2
\&  # Set a 10\-second timer.
\&  $_[KERNEL]\->delay( time_is_up => 10 );
.Ve
.PP
\fI\f(CI$_\fI[\s-1HEAP\s0]\fR
.IX Subsection "$_[HEAP]"
.PP
Every POE::Session object contains its own variable namespace known as
the session's \f(CW\*(C`HEAP\*(C'\fR.  It is modeled and named after process memory
heaps (not priority heaps).  Heaps are by default anonymous hash
references, but they may be initialized in \fIcreate()\fR to be almost
anything.  POE::Session itself never uses \f(CW$_[HEAP]\fR, although some \s-1POE\s0
components do.
.PP
Heaps do not overlap between sessions, although \fIcreate()\fR's \*(L"heap\*(R"
parameter can be used to make this happen.
.PP
These two handlers time the lifespan of a session:
.PP
.Vb 3
\&  sub _start_handler {
\&    $_[HEAP]{ts_start} = time();
\&  }
\&
\&  sub _stop_handler {
\&    my $time_elapsed = time() \- $_[HEAP]{ts_start};
\&    print "Session ", $_[SESSION]\->ID, " elapsed seconds: $elapsed\en";
\&  }
.Ve
.PP
\fI\f(CI$_\fI[\s-1STATE\s0]\fR
.IX Subsection "$_[STATE]"
.PP
The STATEth handler parameter contains the name of the event being
dispatched in the current callback.  This can be important since the
event and handler names may significantly differ.  Also, a single
handler may be assigned to more than one event.
.PP
.Vb 11
\&  POE::Session\->create(
\&    inline_states => {
\&      one => \e&some_handler,
\&      two => \e&some_handler,
\&      six => \e&some_handler,
\&      ten => \e&some_handler,
\&      _start => sub {
\&        $_[KERNEL]\->yield($_) for qw(one two six ten);
\&      }
\&    }
\&  );
\&
\&  sub some_handler {
\&    print(
\&      "Session ", $_[SESSION]\->ID,
\&      ": some_handler() handled event $_[STATE]\en"
\&    );
\&  }
.Ve
.PP
It should be noted however that having event names and handlers names match
will make your code easier to navigate.
.PP
\fI\f(CI$_\fI[\s-1SENDER\s0]\fR
.IX Subsection "$_[SENDER]"
.PP
Events must come from somewhere.  \f(CW$_[SENDER]\fR contains the currently
dispatched event's source.
.PP
\&\f(CW$_[SENDER]\fR is commonly used as a return address for responses.  It may
also be compared against \f(CW$_[KERNEL]\fR to verify that timers and other
POE::Kernel\-generated events were not spoofed.
.PP
This \f(CW\*(C`echo_handler()\*(C'\fR reponds to the sender with an \*(L"echo\*(R" event that
contains all the parameters it received.  It avoids a feedback loop by
ensuring the sender session and event (\s-1STATE\s0) are not identical to the
current ones.
.PP
.Vb 4
\&  sub echo_handler {
\&    return if $_[SENDER] == $_[SESSION] and $_[STATE] eq "echo";
\&    $_[KERNEL]\->post( $_[SENDER], "echo", @_[ARG0..$#_] );
\&  }
.Ve
.PP
\&\s-1TODO\s0 \- Document which events should have \f(CW$_\fR[\s-1SENDER\s0] == \f(CW$_\fR[\s-1KERNEL\s0].
Probably in POE::Kernel.
.PP
\fI\f(CI$_\fI[\s-1CALLER_FILE\s0], \f(CI$_\fI[\s-1CALLER_LINE\s0] and \f(CI$_\fI[\s-1CALLER_STATE\s0]\fR
.IX Subsection "$_[CALLER_FILE], $_[CALLER_LINE] and $_[CALLER_STATE]"
.PP
These parameters are a form of \fIcaller()\fR, but they describe where the
currently dispatched event originated.  \s-1CALLER_FILE\s0 and \s-1CALLER_LINE\s0
are fairly plain.  \s-1CALLER_STATE\s0 contains the name of the event that
was being handled when the event was created, or when the event
watcher that ultimately created the event was registered.
.PP
\&\s-1TODO\s0 \- Rename \s-1SENDER_FILE\s0, \s-1SENDER_LINE\s0, \s-1SENDER_STATE\s0?
.PP
\fI\f(CI@_\fI[\s-1ARG0\s0..ARG9] or \f(CI@_\fI[\s-1ARG0\s0..$#_]\fR
.IX Subsection "@_[ARG0..ARG9] or @_[ARG0..$#_]"
.PP
Parameters \f(CW$_\fR[\s-1ARG0\s0] through the end of \f(CW@_\fR contain parameters provided
by application code, event watchers, or higher-level libraries.  These
parameters are guaranteed to be at the end of \f(CW@_\fR so that \f(CW@_\fR[\s-1ARG0\s0..$#_]
will always catch them all.
.PP
$#_ is the index of the last value in \f(CW@_\fR.  Blame Perl if it looks odd.
It's merely the $#array syntax where the array name is an underscore.
.PP
Consider
.PP
.Vb 1
\&  $_[KERNEL]\->yield( ev_whatever => qw( zero one two three ) );
.Ve
.PP
The handler for ev_whatever will be called with \*(L"zero\*(R" in \f(CW$_\fR[\s-1ARG0\s0],
\&\*(L"one\*(R" in \f(CW$_\fR[\s-1ARG1\s0], and so on.  \f(CW@_\fR[\s-1ARG0\s0..$#_] will contain all four
words.
.PP
.Vb 3
\&  sub ev_whatever {
\&    $_[OBJECT]\->whatever( @_[ARG0..$#_] );
\&  }
.Ve
.SS "Using POE::Session With Objects"
.IX Subsection "Using POE::Session With Objects"
One session may handle events across many objects.  Or looking at it
the other way, multiple objects can be combined into one session.  And
what the heck\-\-\-go ahead and mix in some inline code as well.
.PP
.Vb 9
\&  POE::Session\->create(
\&    object_states => [
\&      $object_1 => { event_1a => "method_1a" },
\&      $object_2 => { event_2a => "method_2a" },
\&    ],
\&    inline_states => {
\&      event_3 => \e&piece_of_code,
\&    },
\&  );
.Ve
.PP
However only one handler may be assigned to a given event name.
Duplicates will overwrite earlier ones.
.PP
event_1a is handled by calling \f(CW\*(C`$object_1\->method_1a(...)\*(C'\fR.  \f(CW$_[OBJECT]\fR
is \f(CW$object_1\fR in this case.  \f(CW$_[HEAP]\fR belongs to the session, which
means anything stored there will be available to any other event
handler regardless of the object.
.PP
event_2a is handled by calling \f(CW\*(C`$object_2\->method_2a(...)\*(C'\fR.  In this
case \f(CW$_[OBJECT]\fR is \f(CW$object_2\fR.  \f(CW$_[HEAP]\fR is the same anonymous hashref
that was passed to the event_1a handler, though.  The methods are resolved
when the event is handled (late-binding).
.PP
event_3 is handled by calling \f(CW\*(C`piece_of_code(...)\*(C'\fR.  \f(CW$_[OBJECT]\fR is \f(CW\*(C`undef\*(C'\fR
here because there's no object.  And once again, \f(CW$_[HEAP]\fR is the same
shared hashref that the handlers for event_1a and event_2a saw.
.PP
Interestingly, there's no technical reason that a
single object can't handle events from more than one session:
.PP
.Vb 7
\&  for (1..2) {
\&    POE::Session\->create(
\&      object_states => [
\&        $object_4 => { event_4 => "method_4" },
\&      ]
\&    );
\&  }
.Ve
.PP
Now \f(CW\*(C`$object_4\->method_4(...)\*(C'\fR may be called to handle events from one of
two sessions.  In both cases, \f(CW$_[OBJECT]\fR will be \f(CW$object_4\fR, but
\&\f(CW$_[HEAP]\fR will hold data for a particular session.
.PP
The same goes for inline states.  One subroutine may handle events
from many sessions.  \f(CW$_[SESSION]\fR and \f(CW$_[HEAP]\fR can be used within the
handler to easily access the context of the session in which the event
is being handled.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
POE::Session has just a few public methods.
.SS "create \s-1LOTS_OF_STUFF\s0"
.IX Subsection "create LOTS_OF_STUFF"
\&\f(CW\*(C`create()\*(C'\fR starts a new session running.  It returns a new POE::Session
object upon success, but most applications won't need to save it.
.PP
\&\f(CW\*(C`create()\*(C'\fR invokes the newly started session's _start event handler
before returning.
.PP
\&\f(CW\*(C`create()\*(C'\fR also passes the new POE::Session object to POE::Kernel.
\&\s-1POE\s0's kernel holds onto the object in order to dispatch events to it.
POE::Kernel will release the object when it detects the object has
become moribund.  This should cause Perl to destroy the object if
application code has not saved a copy of it.
.PP
\&\f(CW\*(C`create()\*(C'\fR accepts several named parameters, most of which are optional.
Note however that the parameters are not part of a hashref.
.PP
\&\s-1TODO\s0 \- Is it time to bring \fInew()\fR back as a synonym for \fIcreate()\fR?
\&\s-1TODO\s0 \s-1PG\s0 \- \s-1NO\s0!  \s-1IMHO\s0 \->new implies simply creating the object, and 
\&\s-1TODO\s0 that you have to hold onto the object.  \->create implies other actions
\&\s-1TODO\s0 are happening, and that you don't want to hold on to it.
.PP
\&\s-1TODO\s0 \- Provide forward-compatible \*(L"handler\*(R" options and methods as
synonyms for the \*(L"state\*(R" versions currently supported?
\&\s-1TODO\s0 \s-1PG\s0 \- No, that's for 1.01
.PP
\&\s-1TODO\s0 \- Add a \*(L"class_handlers\*(R" as a synonym for \*(L"package_handlers\*(R"?
\&\s-1TODO\s0 \s-1PG\s0 \- Maybe. However, to many synonyms can be a pain for an \s-1API\s0.
.PP
\&\s-1TODO\s0 \- The above TODOs may be summarized: \*(L"deprecate old language\*(R"?
\&\s-1TODO\s0 \s-1PG\s0 \- Oh, you are thinking of deprecating the old language... erm... no?
.PP
\&\s-1TODO\s0 \s-1PG\s0 \- I notice these =head3 are in alphabetical order.  I think
\&\s-1TODO\s0 all the *_states options should be together.  Followed by heap, args,
\&\s-1TODO\s0 options
.PP
\fIargs => \s-1ARRAYREF\s0\fR
.IX Subsection "args => ARRAYREF"
.PP
The \f(CW\*(C`args\*(C'\fR parameter accepts a reference to a list of parameters that
will be passed to the session's _start event handler in \f(CW@_\fR positions
\&\f(CW\*(C`ARG0\*(C'\fR through \f(CW$#_\fR (the end of \f(CW@_\fR).
.PP
This example would print \*(L"arg0 arg1 etc.\*(R":
.PP
.Vb 8
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        print "Session started with arguments: @_[ARG0..$#_]\en";
\&      },
\&    },
\&    args => [ \*(Aqarg0\*(Aq, \*(Aqarg1\*(Aq, \*(Aqetc.\*(Aq ],
\&  );
.Ve
.PP
\fIheap => \s-1ANYTHING\s0\fR
.IX Subsection "heap => ANYTHING"
.PP
The \f(CW\*(C`heap\*(C'\fR parameter allows a session's heap to be initialized
differently at instantiation time.  Heaps are usually anonymous
hashrefs, but \f(CW\*(C`heap\*(C'\fR may set them to be array references or even
objects.
.PP
This example prints \*(L"tree\*(R":
.PP
.Vb 8
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        print "Slot 0 = $_[HEAP][0]\en";
\&      },
\&    },
\&    heap => [ \*(Aqtree\*(Aq, \*(Aqbear\*(Aq ],
\&  );
.Ve
.PP
Be careful when initializing the heap to be something that doesn't behave
like a hashref.  Some libraries assume hashref heap semantics, and
they will fail if the heap doesn't work that way.
.PP
\fIinline_states => \s-1HASHREF\s0\fR
.IX Subsection "inline_states => HASHREF"
.PP
\&\f(CW\*(C`inline_states\*(C'\fR maps events names to the subroutines that will handle
them.  Its value is a hashref that maps event names to the coderefs of
their corresponding handlers:
.PP
.Vb 9
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        print "arg0=$_[ARG0], arg1=$_[ARG1], etc.=$_[ARG2]\en";
\&      },
\&      _stop  => \e&stop_handler,
\&    },
\&    args => [qw( arg0 arg1 etc. )],
\&  );
.Ve
.PP
The term \*(L"inline\*(R" comes from the fact that coderefs can be inlined
anonymous subroutines.
.PP
Be very careful with closures, however.  \*(L"Beware circular references\*(R".
.PP
\fIobject_states => \s-1ARRAYREF\s0\fR
.IX Subsection "object_states => ARRAYREF"
.PP
\&\f(CW\*(C`object_states\*(C'\fR associates one or more objects to a session and maps
event names to the object methods that will handle them.  It's value
is an \f(CW\*(C`ARRAYREF\*(C'\fR; \f(CW\*(C`HASHREFs\*(C'\fR would stringify the objects, ruining them
for method invocation.
.PP
Here _start is handled by \f(CW\*(C`$object\->_session_start()\*(C'\fR and _stop triggers
\&\f(CW\*(C`$object\->_session_stop()\*(C'\fR:
.PP
.Vb 8
\&  POE::Session\->create(
\&    object_states => [
\&      $object => {
\&        _start => \*(Aq_session_start\*(Aq,
\&        _stop  => \*(Aq_session_stop\*(Aq,
\&      }
\&    ]
\&  );
.Ve
.PP
POE::Session also supports a short form where the event and method
names are identical.  Here _start invokes \f(CW$object\fR\->\fI_start()\fR, and _stop
triggers \f(CW$object\fR\->\fI_stop()\fR:
.PP
.Vb 5
\&  POE::Session\->create(
\&    object_states => [
\&      $object => [ \*(Aq_start\*(Aq, \*(Aq_stop\*(Aq ],
\&    ]
\&  );
.Ve
.PP
Methods are verified when the session is created, but also resolved when the
handler is called (late binding).  Most of the time, a method won't change.
But in some circumstance, such as dynamic inheritance, a method could
resolve to a different subroutine.
.PP
\fIoptions => \s-1HASHREF\s0\fR
.IX Subsection "options => HASHREF"
.PP
POE::Session sessions support a small number of options, which may be
initially set with the \f(CW\*(C`option\*(C'\fR constructor parameter and changed at
run time with the \f(CW\*(C`option()|/option\*(C'\fR mehtod.
.PP
\&\f(CW\*(C`option\*(C'\fR takes a hashref with option => value pairs:
.PP
.Vb 4
\&  POE::Session\->create(
\&    ... set up handlers ...,
\&    options => { trace => 1, debug => 1 },
\&  );
.Ve
.PP
This is equivalent to the previous example:
.PP
.Vb 3
\&  POE::Session\->create(
\&    ... set up handlers ...,
\&  )\->option( trace => 1, debug => 1 );
.Ve
.PP
The supported options and values are documented with the \f(CW\*(C`option()|/option\*(C'\fR
method.
.PP
\fIpackage_states => \s-1ARRAYREF\s0\fR
.IX Subsection "package_states => ARRAYREF"
.PP
\&\f(CW\*(C`package_states\*(C'\fR associates one or more classes to a session and maps
event names to the class methods that will handle them.  Its function
is analogous to \f(CW\*(C`object_states\*(C'\fR, but package names are specified
rather than objects.
.PP
In fact, the following documentation is a copy of the \f(CW\*(C`object_states\*(C'\fR
description with some word substitutions.
.PP
The value for \f(CW\*(C`package_states\*(C'\fR is an \fB\s-1ARRAYREF\s0\fR to be consistent
with \f(CW\*(C`object_states\*(C'\fR, even though class names (also known as package names) are
already strings, so it's not necessary to avoid stringifying them.
.PP
Here _start is handled by \f(CW\*(C`$class_name\->_session_start()\*(C'\fR and _stop
triggers \f(CW\*(C`$class_name\->_session_stop()\*(C'\fR:
.PP
.Vb 8
\&  POE::Session\->create(
\&    package_states => [
\&      $class_name => {
\&        _start => \*(Aq_session_start\*(Aq,
\&        _stop  => \*(Aq_session_stop\*(Aq,
\&      }
\&    ]
\&  );
.Ve
.PP
POE::Session also supports a short form where the event and method
names are identical.  Here _start invokes \f(CW\*(C`$class_name\->_start()\*(C'\fR, and
_stop triggers \f(CW\*(C`$class_name\->_stop()\*(C'\fR:
.PP
.Vb 5
\&  POE::Session\->create(
\&    package_states => [
\&      $class_name => [ \*(Aq_start\*(Aq, \*(Aq_stop\*(Aq ],
\&    ]
\&  );
.Ve
.SS "\s-1ID\s0"
.IX Subsection "ID"
\&\f(CW\*(C`ID()\*(C'\fR returns the session instance's unique identifier.  This is an
integer that starts at 1 and counts up forever, or until the number
wraps around.
.PP
It's theoretically possible that a session \s-1ID\s0 will not be unique, but
this requires at least 4.29 billion sessions to be created within a
program's lifespan.  \s-1POE\s0 guarantees that no two sessions will have the
same \s-1ID\s0 at the same time, however;  your computer doesn't have enough memory
to store 4.29 billion session objects.
.PP
A session's \s-1ID\s0 is unique within a running process, but multiple
processes are likely to have the same session IDs.  If a global \s-1ID\s0 is
required, it will need to include both \f(CW\*(C`$_[KERNEL]\->ID\*(C'\fR and
\&\f(CW\*(C`$_[SESSION]\->ID\*(C'\fR.
.SS "option \s-1OPTION_NAME\s0 [, \s-1OPTION_VALUE\s0 [, \s-1OPTION_NAME\s0, \s-1OPTION_VALUE\s0]... ]"
.IX Subsection "option OPTION_NAME [, OPTION_VALUE [, OPTION_NAME, OPTION_VALUE]... ]"
\&\f(CW\*(C`option()\*(C'\fR sets and/or retrieves the values of various session options.
The options in question are implemented by POE::Session and do not
have any special meaning anywhere else.
.PP
It may be called with a single \s-1OPTION_NAME\s0 to retrieve the value of
that option.
.PP
.Vb 1
\&  my $trace_value = $_[SESSION]\->option(\*(Aqtrace\*(Aq);
.Ve
.PP
\&\f(CW\*(C`option()\*(C'\fR sets an option's value when called with a single \s-1OPTION_NAME\s0,
\&\s-1OPTION_VALUE\s0 pair.  In this case, \f(CW\*(C`option()\*(C'\fR returns the option's
previous value.
.PP
.Vb 1
\&  my $previous_trace = $_[SESSION]\->option(trace => 1);
.Ve
.PP
\&\f(CW\*(C`option()\*(C'\fR may also be used to set the values of multiple options at
once.  In this case, \f(CW\*(C`option()\*(C'\fR returns all the specified options'
previous values in an anonymous hashref:
.PP
.Vb 4
\&  my $previous_values = $_[SESSION]\->option(
\&    trace => 1,
\&    debug => 1,
\&  );
\&
\&  print "Previous option values:\en";
\&  while (my ($option, $old_value) = each %$previous_values) {
\&    print "  $option = $old_value\en";
\&  }
.Ve
.PP
POE::Session currently supports three options:
.PP
\fIThe \*(L"debug\*(R" option.\fR
.IX Subsection "The debug option."
.PP
The \*(L"debug\*(R" option is intended to enable additional warnings when
strange things are afoot within POE::Session.  At this time, there is
only one additional warning:
.IP "\(bu" 4
Redefining an event handler does not usually cause a warning, but it
will when the \*(L"debug\*(R" option is set.
.PP
\fIThe \*(L"default\*(R" option.\fR
.IX Subsection "The default option."
.PP
Enabling the \*(L"default\*(R" option causes unknown events to become
warnings, if there is no _default handler to catch them.
.PP
The class-level \f(CW\*(C`POE::Session::ASSERT_STATES\*(C'\fR flag is implemented by
enabling the \*(L"default\*(R" option on all new sessions.
.PP
\fIThe \*(L"trace\*(R" option.\fR
.IX Subsection "The trace option."
.PP
Turn on the \*(L"trace\*(R" option to dump a log of all the events dispatched
to a particular session.  This is a session-specific trace option that
allows individual sessions to be debugged.
.PP
Session-level tracing also indicates when events are redirected to
_default.  This can be used to discover event naming errors.
.PP
\fIUser-defined options.\fR
.IX Subsection "User-defined options."
.PP
\&\f(CW\*(C`option()\*(C'\fR does not verify whether OPTION_NAMEs are known, so \f(CW\*(C`option()\*(C'\fR
may be used to store and retrieve user-defined information.
.PP
Choose option names with caution.  There is no established convention
to avoid namespace collisions between user-defined options and future
internal options.
.SS "postback \s-1EVENT_NAME\s0, \s-1EVENT_PARAMETERS\s0"
.IX Subsection "postback EVENT_NAME, EVENT_PARAMETERS"
\&\f(CW\*(C`postback()\*(C'\fR manufactures callbacks that post \s-1POE\s0 events.  It returns an
anonymous code reference that will post \s-1EVENT_NAME\s0 to the target
session, with optional \s-1EVENT_PARAMETERS\s0 in an array reference in \s-1ARG0\s0.
Parameters passed to the callback will be sent in an array reference
in \s-1ARG1\s0.
.PP
In other words, \s-1ARG0\s0 allows the postback's creator to pass context
through the postback.  \s-1ARG1\s0 allows the caller to return information.
.PP
This example creates a coderef that when called posts \*(L"ok_button\*(R" to
\&\f(CW$some_session\fR with \s-1ARG0\s0 containing \f(CW\*(C`[ 8, 6, 7 ]\*(C'\fR.
.PP
.Vb 1
\&  my $postback = $some_session\->postback( "ok_button", 8, 6, 7 );
.Ve
.PP
Here's an example event handler for \*(L"ok_button\*(R".
.PP
.Vb 5
\&  sub handle_ok_button {
\&    my ($creation_args, $called_args) = @_[ARG0, ARG1];
\&    print "Postback created with (@$creation_args).\en";
\&    print "Postback called with (@$called_args).\en";
\&  }
.Ve
.PP
Calling \f(CW$postback\fR\->(5, 3, 0, 9) would perform the equivalent of...
.PP
.Vb 5
\&  $poe_kernel\->post(
\&    $some_session, "ok_button",
\&    [ 8, 6, 7 ],
\&    [ 5, 3, 0, 9 ]
\&  );
.Ve
.PP
This would be displayed when \*(L"ok_button\*(R" was dispatched to
\&\fIhandle_ok_button()\fR:
.PP
.Vb 2
\&  Postback created with (8 6 7).
\&  Postback called with (5 3 0 9).
.Ve
.PP
Postbacks hold references to their target sessions.  Therefore
sessions with outstanding postbacks will remain active.  Under every
event loop except Tk, postbacks are blessed so that \s-1DESTROY\s0 may be
called when their users are done.  This triggers a decrement on their
reference counts, allowing sessions to stop.
.PP
Postbacks have one method, \fIweaken()\fR, which may be used to reduce their
reference counts upon demand.  \fIweaken()\fR returns the postback, so you
can do:
.PP
.Vb 1
\&  my $postback = $session\->postback("foo")\->weaken();
.Ve
.PP
Postbacks were created as a thin adapter between callback libraries
and \s-1POE\s0.  The problem at hand was how to turn callbacks from the Tk
graphical toolkit's widgets into \s-1POE\s0 events without subclassing
several Tk classes.  The solution was to provide Tk with plain old
callbacks that posted \s-1POE\s0 events.
.PP
Since \f(CW\*(C`postback()\*(C'\fR and \f(CW\*(C`callback()\*(C'\fR are Session methods, they may be
called on \f(CW$_[SESSION]\fR or \f(CW$_[SENDER]\fR, depending on particular needs.
There are usually better ways to interact between sessions than
abusing postbacks, however.
.PP
Here's a brief example of attaching a Gtk2 button to a \s-1POE\s0 event
handler:
.PP
.Vb 2
\&  my $btn = Gtk2::Button\->new("Clear");
\&  $btn\->signal_connect( "clicked", $_[SESSION]\->postback("ev_clear") );
.Ve
.PP
Points to remember: The session will remain alive as long as \f(CW$btn\fR
exists and holds a copy of \f(CW$_\fR[\s-1SESSION\s0]'s postback.  Any parameters
passed by the Gtk2 button will be in \s-1ARG1\s0.
.SS "callback \s-1EVENT_NAME\s0, \s-1EVENT_PARAMETERS\s0"
.IX Subsection "callback EVENT_NAME, EVENT_PARAMETERS"
\&\fIcallback()\fR manufactures callbacks that use \f(CW\*(C`$poe_kernel\->call()\*(C'\fR to
deliver \s-1POE\s0 events rather than \f(CW\*(C`$poe_kernel\->post()\*(C'\fR.  It is identical
to \f(CW\*(C`postback()\*(C'\fR in every other respect.
.PP
\&\fIcallback()\fR was created to avoid race conditions that arise when
external libraries assume callbacks will execute synchronously.
File::Find is an obvious (but not necessarily appropriate) example.
It provides a lot of information in local variables that stop being
valid after the callback.  The information would be unavailable by the
time a \fIpost()\fRed event was dispatched.
.SS "get_heap"
.IX Subsection "get_heap"
\&\f(CW\*(C`get_heap()\*(C'\fR returns a reference to a session's heap.  This is the same
value as \f(CW$_[HEAP]\fR for the target session.  \f(CW\*(C`get_heap()\*(C'\fR is intended to
be used with \f(CW$poe_kernel\fR and POE::Kernel's \f(CW\*(C`get_active_session()\*(C'\fR so
that libraries do not need these three common values explicitly passed
to them.
.PP
That is, it prevents the need for:
.PP
.Vb 4
\&  sub some_helper_function {
\&    my ($kernel, $session, $heap, @specific_parameters) = @_;
\&    ...;
\&  }
.Ve
.PP
Rather, helper functions may use:
.PP
.Vb 6
\&  use POE::Kernel; # exports $poe_kernel
\&  sub some_helper_function {
\&    my (@specific_parameters) = @_;
\&    my $session = $poe_kernel\->get_active_session();
\&    my $heap = $session\->get_heap();
\&  }
.Ve
.PP
This isn't very convenient for people writing libraries, but it makes
the libraries much more convenient to use.
.PP
Using \f(CW\*(C`get_heap()\*(C'\fR to break another session's encapsulation is strongly
discouraged.
.SS "instantiate \s-1CREATE_PARAMETERS\s0"
.IX Subsection "instantiate CREATE_PARAMETERS"
\&\f(CW\*(C`instantiate()\*(C'\fR creates and returns an empty POE::Session object.  It is
called with the \s-1CREATE_PARAMETERS\s0 in a hash reference just before
\&\f(CW\*(C`create()\*(C'\fR processes them.  Modifications to the \s-1CREATE_PARAMETERS\s0 will
affect how \f(CW\*(C`create()\*(C'\fR initializes the new session.
.PP
Subclasses may override \f(CW\*(C`instantiate()\*(C'\fR to alter the underlying
session's structure.  They may extend \f(CW\*(C`instantiate()\*(C'\fR to add new
parameters to \f(CW\*(C`create()\*(C'\fR.
.PP
Any parameters not recognized by \f(CW\*(C`create()\*(C'\fR must be removed from the
\&\s-1CREATE_PARAMETERS\s0 before \f(CW\*(C`instantiate()\*(C'\fR returns.  \f(CW\*(C`create()\*(C'\fR will
croak
if it discovers unknown parameters.
.PP
Be sure to return \f(CW$self\fR from instantiate.
.PP
.Vb 2
\&  sub instantiate {
\&    my ($class, $create_params) = @_;
\&
\&    # Have the base class instantiate the new session.
\&    my $self = $class\->SUPER::instantiate($create_parameters);
\&
\&    # Extend the parameters recognized by create().
\&    my $new_option = delete $create_parameters\->{new_option};
\&    if (defined $new_option) {
\&      # ... customize $self here ...
\&    }
\&
\&    return $self;
\&  }
.Ve
.SS "try_alloc \s-1START_ARGS\s0"
.IX Subsection "try_alloc START_ARGS"
\&\f(CW\*(C`try_alloc()\*(C'\fR calls POE::Kernel's \f(CW\*(C`session_alloc()\*(C'\fR to allocate a session
structure and begin managing the session within \s-1POE\s0's kernel.  It is
called at the end of POE::Session's \f(CW\*(C`create()\*(C'\fR.  It returns \f(CW$self\fR.
.PP
It is a subclassing hook for late session customization prior to
\&\f(CW\*(C`create()\*(C'\fR returning.  It may also affect the contents of \f(CW@_[ARG0..$#_]\fR
that are passed to the session's _start handler.
.PP
.Vb 2
\&  sub try_alloc {
\&    my ($self, @start_args) = @_;
\&
\&    # Perform late initialization.
\&    # ...
\&
\&    # Give $self to POE::Kernel.
\&    return $self\->SUPER::try_alloc(@args);
\&  }
.Ve
.SH "POE::Session's EVENTS"
.IX Header "POE::Session's EVENTS"
Please do not define new events that begin with a leading underscore.
\&\s-1POE\s0 claims /^_/ events as its own.
.PP
POE::Session only generates one event, _default.  All other internal
\&\s-1POE\s0 events are generated by (and documented in) POE::Kernel.
.SS "_default"
.IX Subsection "_default"
_default is the \f(CW\*(C`AUTOLOAD\*(C'\fR of event handlers.  If POE::Session can't
find a handler at dispatch time, it attempts to redirect the event to
_default's handler instead.
.PP
If there's no _default handler, POE::Session will silently drop the
event unless the \*(L"default\*(R" option is set.
.PP
To preserve the original information, the original event is slightly
changed before being redirected to the _default handler:  The original
event parameters are moved to an array reference in \s-1ARG1\s0, and the
original event name is passed to _default in \s-1ARG0\s0.
.PP
.Vb 7
\&  sub handle_default {
\&    my ($event, $args) = @_[ARG0, ARG1];
\&    print(
\&      "Session ", $_[SESSION]\->ID,
\&      " caught unhandled event $event with (@$args).\en"
\&    );
\&  }
.Ve
.PP
_default is quite flexible.  It may be used for debugging, or to
handle dynamically generated event names without pre-defining their
handlers.  In the latter sense, _default performs analogously to
Perl's \f(CW\*(C`AUTOLOAD\*(C'\fR.
.PP
_default may also be used as the default or \*(L"otherwise\*(R" clause of a
switch statement.  Consider an input handler that throws events based
on a command name:
.PP
.Vb 4
\&  sub parse_command {
\&    my ($command, @parameters) = split /\es+/, $_[ARG0];
\&    $_[KERNEL]\->post( "cmd_$command", @parameters );
\&  }
.Ve
.PP
A _default handler may be used to emit errors for unknown commands:
.PP
.Vb 5
\&  sub handle_default {
\&    my $event = $_[ARG0];
\&    return unless $event =~ /^cmd_(\eS+)/;
\&    warn "Unknown command: $1\en";
\&  }
.Ve
.PP
The _default behavior is implemented in POE::Session, so it may be
different for other session types.
.SS "POE::Session's Debugging Features"
.IX Subsection "POE::Session's Debugging Features"
POE::Session contains one debugging assertion, for now.
.PP
\fI\s-1ASSERT_STATES\s0\fR
.IX Subsection "ASSERT_STATES"
.PP
Setting \s-1ASSERT_STATES\s0 to true causes every Session to warn when they
are asked to handle unknown events.  Session.pm implements the guts of
\&\s-1ASSERT_STATES\s0 by defaulting the \*(L"default\*(R" option to true instead of
false.  See the \fIoption()\fR method earlier in this document for details
about the \*(L"default\*(R" option.
.PP
\&\s-1TODO\s0 \- It's not much of an assertion if it only warns.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
POE::Kernel.
.PP
The \s-1SEE\s0 \s-1ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.SH "BUGS"
.IX Header "BUGS"
There is a chance that session IDs may collide after Perl's integer
value wraps.  This can occur after as \fIfew\fR as 4.29 billion sessions.
.SS "Beware circular references"
.IX Subsection "Beware circular references"
As you're probably aware, a circular reference is when a variable is
part of a reference chain that eventually refers back to itself.  Perl
will not reclaim the memory involved in such a reference chain until
the chain is manually broken.
.PP
Here a POE::Session is created that refers to itself via an external
scalar.  The event handlers import \f(CW$session\fR via closures which are in
turn stored within \f(CW$session\fR.  Even if this session stops, the circular
references will remain.
.PP
.Vb 10
\&  my $session;
\&  $session = POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        $_[HEAP]\->{todo} = [ qw( step1 step2 step2a ) ],
\&        $_[KERNEL]\->post( $session, \*(Aqnext\*(Aq );
\&      },
\&      next => sub {
\&        my $next = shift @{ $_[HEAP]\->{todo} };
\&        return unless $next;
\&        $_[KERNEL]\->post( $session, $next );
\&      }
\&      # ....
\&    }
\&  );
.Ve
.PP
Reduced to its essence:
.PP
.Vb 2
\&  my %event_handlers;
\&  $event_handler{_start} = sub { \e%event_handlers };
.Ve
.PP
Note also that a anonymous sub creates a closure on all lexical
variables in the scope it was defined in, even if it doesn't reference
them.  \f(CW$session\fR is still being held in a circular reference here:
.PP
.Vb 7
\&  my $self = $package\->new;
\&  my $session;
\&  $session = POE::Session\->create(
\&    inline_state => {
\&      _start => sub { $self\->_start( @_[ARG0..$#_] ) }
\&    }
\&  );
.Ve
.PP
To avoid this, a session may set an alias for itself.  Other parts of
the program may then refer to it by alias.  In this case, one needn't
keep track of the session themselves (POE::Kernel will do it anyway).
.PP
.Vb 10
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        $_[HEAP]\->{todo} = [ qw( step1 step2 step2a ) ],
\&        $_[KERNEL]\->alias_set(\*(Aqstep_doer\*(Aq);
\&        $_[KERNEL]\->post( \*(Aqstep_doer\*(Aq, \*(Aqnext\*(Aq );
\&      },
\&      next => sub {
\&        my $next = shift @{ $_[HEAP]\->{todo} };
\&        return unless $next;
\&        $_[KERNEL]\->post( \*(Aqstep_doer\*(Aq, $next );
\&      }
\&      # ....
\&    }
\&  );
.Ve
.PP
Aliases aren't even needed in the previous example because the session
refers to itself.  One could instead use POE::Kernel's \fIyield()\fR method
to post the event back to the current session:
.PP
.Vb 5
\&  next => sub {
\&    my $next = shift @{ $_[HEAP]\->{todo} };
\&    return unless $next;
\&    $_[KERNEL]\->yield( $next );
\&  }
.Ve
.PP
Or the \*(L"$_[\s-1SESSION\s0]\*(R" parameter passed to every event handler, but
\&\fIyield()\fR is more efficient.
.PP
.Vb 5
\&  next => sub {
\&    my $next = shift @{ $_[HEAP]\->{todo} };
\&    return unless $next;
\&    $_[KERNEL]\->post( $_[SESSION], $next );
\&  }
.Ve
.PP
Along the same lines as \*(L"$_[\s-1SESSION\s0]\*(R", a session can respond back to
the sender of an event by posting to \*(L"$_[\s-1SENDER\s0]\*(R".  This is great for
responding to requests.
.PP
If a program must hold onto some kind of dynamic session reference,
it's recommended to use the session's numeric \s-1ID\s0 rather than the
object itself.  A session \s-1ID\s0 may be converted back into its object,
but \fIpost()\fR accepts session IDs as well as objects and aliases:
.PP
.Vb 10
\&  my $session_id;
\&  $session_id = POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        $_[HEAP]\->{todo} = [ qw( step1 step2 step2a ) ],
\&        $_[KERNEL]\->post( $session_id, \*(Aqnext\*(Aq );
\&      },
\&      # ....
\&    }
\&  )\->ID;
.Ve
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
Please see \s-1POE\s0 for more information about authors and contributors.
