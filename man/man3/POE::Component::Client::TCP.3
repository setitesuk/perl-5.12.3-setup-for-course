.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POE::Component::Client::TCP 3"
.TH POE::Component::Client::TCP 3 "2010-11-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Component::Client::TCP \- a simplified TCP client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #!perl
\&
\&  use warnings;
\&  use strict;
\&
\&  use POE qw(Component::Client::TCP);
\&
\&  POE::Component::Client::TCP\->new(
\&    RemoteAddress => "yahoo.com",
\&    RemotePort    => 80,
\&    Connected     => sub {
\&      $_[HEAP]{server}\->put("HEAD /");
\&    },
\&    ServerInput   => sub {
\&      my $input = $_[ARG0];
\&      print "from server: $input\en";
\&    },
\&  );
\&
\&  POE::Kernel\->run();
\&  exit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Component::Client::TCP implements a generic single-Session
client.  Internally it uses POE::Wheel::SocketFactory to establish the
connection and POE::Wheel::ReadWrite to interact with the server.
.PP
POE::Component::Cilent::TCP is customized by providing callbacks for
common operations.  Most operations have sensible default callbacks,
so clients may be created with as little work as possible.
.SS "Performance Considerations"
.IX Subsection "Performance Considerations"
POE::Component::Client::TCP's ease of use comes at a price.  The
component is generic, so it's not tuned to perform well for any
particular application.
.PP
If performance is your primary goal, POE::Kernel's \fIselect_read()\fR and
\&\fIselect_write()\fR perform about the same as IO::Select, but your code
will be portable across every event loop \s-1POE\s0 supports.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.SS "new"
.IX Subsection "new"
\&\fInew()\fR starts a client based on POE::Component::Client::TCP and returns
the \s-1ID\s0 of the session that will handle server interaction.
.PP
\&\fInew()\fR returns immediately, which may be before the client has
established its connection.  It is always reliable to wait for the
\&\f(CW\*(C`Connected\*(C'\fR callback to fire before transmitting data to the server.
.PP
The client's constructor may seem to take a daunting number of
parameters.  As with most \s-1POE\s0 modules, POE::Component::Client::TCP
tries to do as much work in its constructor so that the run-time code
path is relatively light.
.PP
\fIConstructor Parameters Affecting the Session\fR
.IX Subsection "Constructor Parameters Affecting the Session"
.PP
The parameters in this section affect how the client's POE::Session
object will be created.
.PP
Alias
.IX Subsection "Alias"
.PP
\&\f(CW\*(C`Alias\*(C'\fR is an optional symbolic name for the client's Session.  It
allows other sessions to post events to the client, such as \*(L"shutdown\*(R"
and \*(L"reconnect\*(R".  The client itself may \fIyield()\fR these events, so an
alias isn't usually needed.
.PP
.Vb 1
\&  Alias => "client",
.Ve
.PP
Args
.IX Subsection "Args"
.PP
\&\f(CW\*(C`Args\*(C'\fR is optional.  When specified, it holds an \s-1ARRAYREF\s0 that will
be passed to the \f(CW\*(C`Started\*(C'\fR callback via \f(CW@_\fR[\s-1ARG0\s0..$#_].  This allows a
program to pass extra information into the client session.
.PP
InlineStates
.IX Subsection "InlineStates"
.PP
\&\f(CW\*(C`InlineStates\*(C'\fR is optional.  If specified, it must hold a hashref of
named callbacks.  Its syntax is that of POE:Session\->\fIcreate()\fR's
inline_states parameter.
.PP
ObjectStates
.IX Subsection "ObjectStates"
.PP
If \f(CW\*(C`ObjectStates\*(C'\fR is specified, it must holde an arrayref of objects
and the events they will handle.  The arrayref must follow the syntax
for POE::Session\->\fIcreate()\fR's object_states parameter.
.PP
PackageStates
.IX Subsection "PackageStates"
.PP
When the optional \f(CW\*(C`PackageStates\*(C'\fR is set, it must hold an arrayref of
package names and the events they will handle  The arrayref must
follow the syntax for POE::Session\->\fIcreate()\fR's package_states
parameter.
.PP
PreConnect
.IX Subsection "PreConnect"
.PP
\&\f(CW\*(C`PreConnect\*(C'\fR is called before \f(CW\*(C`Connected\*(C'\fR, and it has different
parameters: \f(CW$_\fR[\s-1ARG0\s0] contains a copy of the socket before it's given
to POE::Wheel::ReadWrite for management.  Most \s-1HEAP\s0 members are set,
except of course \f(CW$_\fR[\s-1HEAP\s0]{server}, because the POE::Wheel::ReadWrite
object has not been created yet.  \f(CW\*(C`PreConnect\*(C'\fR may enable \s-1SSL\s0 on the
socket using POE::Component::SSLify.  \f(CW\*(C`PreConnect\*(C'\fR must return a
valid socket to complete the connection; the client will disconnect if
anything else is returned.
.PP
.Vb 3
\&  PreConnect => {
\&    # Convert the socket into an SSL socket.
\&    my $socket = eval { Client_SSLify($_[ARG0]) };
\&
\&    # Disconnect if SSL failed.
\&    return if $@;
\&
\&    # Return the SSL\-ified socket.
\&    return $socket;
\&  }
.Ve
.PP
SessionType
.IX Subsection "SessionType"
.PP
Each client is created within its own Session.  \f(CW\*(C`SessionType\*(C'\fR names
the class that will be used to create the session.
.PP
.Vb 1
\&  SessionType => "POE::Session::MultiDispatch",
.Ve
.PP
\&\f(CW\*(C`SessionType\*(C'\fR is optional.  The component will use \*(L"POE::Session\*(R" by
default.
.PP
SessionParams
.IX Subsection "SessionParams"
.PP
\&\f(CW\*(C`SessionParams\*(C'\fR specifies additional parameters that will be passed
to the \f(CW\*(C`SessionType\*(C'\fR constructor at creation time.  It must be an
array reference.
.PP
.Vb 1
\&  SessionParams => [ options => { debug => 1, trace => 1 } ],
.Ve
.PP
Note: POE::Component::Client::TCP supplies its own POE::Session
constructor parameters.  Conflicts between them and \f(CW\*(C`SessionParams\*(C'\fR
may cause the component to behave erratically.  To avoid such
problems, please limit SessionParams to the \f(CW\*(C`options\*(C'\fR hash.  See
POE::Session for an known options.
.PP
We may enable other options later.  Please let us know if you need
something.
.PP
Started
.IX Subsection "Started"
.PP
\&\f(CW\*(C`Started\*(C'\fR sets an optional callback that will be invoked within the
client session has been started.  The callback's parameters are the
usual for the session's _start handler.
.PP
\&\f(CW\*(C`Args\*(C'\fR may be used to pass additional parameters to \f(CW\*(C`Started\*(C'\fR.  This
can be used to bypass issues introduced by closures.  The values from
\&\f(CW\*(C`Args\*(C'\fR will be included in the \f(CW@_\fR[\s-1ARG0\s0..$#_] parameters.
.PP
.Vb 4
\&  sub handle_started {
\&    my @args = @_[ARG0..$#_];
\&    # ...
\&  }
.Ve
.PP
\fIPOE::Wheel::SocketFactory Constructor Parameters\fR
.IX Subsection "POE::Wheel::SocketFactory Constructor Parameters"
.PP
The constructor parameters in this section affect how the client's
POE::Wheel::SocketFactory object will be created.
.PP
BindAddress
.IX Subsection "BindAddress"
.PP
\&\f(CW\*(C`BindAddress\*(C'\fR specifies the local interface address to bind to before
starting to connect.  This allows the client to connect from a
specific address when multiple interfaces are available.
.PP
\&\f(CW\*(C`BindAddress\*(C'\fR is optional.  If specified, its value will be passed
directly to POE::Wheel::SocketFactory's BindAddress constructor
parameter.
.PP
BindPort
.IX Subsection "BindPort"
.PP
\&\f(CW\*(C`BindPort\*(C'\fR sets the local socket port that the client will be bound
to before starting to connect.  This allows the client to connect from
a specific port.
.PP
It's not usually necessary to bind to a particular port, so
\&\f(CW\*(C`BindPort\*(C'\fR is optional and disabled by default.
.PP
If specified, the value in \f(CW\*(C`BindPort\*(C'\fR is passed directly to
POE::Wheel::SocketFactory's own BindPort constructor parameter.
.PP
ConnectError
.IX Subsection "ConnectError"
.PP
\&\f(CW\*(C`ConnectError\*(C'\fR is an optional callback to handle errors from
POE::Wheel::SocketFactory.  These errors happen when a socket can't be
created or has trouble connecting to the remote host.
.PP
The following parameters will be passed to the callback along with the
usual \s-1POE\s0 event parameters:  \f(CW$_\fR[\s-1ARG0\s0] will describe what was happening
at the time of failure.  \f(CW$_\fR[\s-1ARG1\s0] and \f(CW$_\fR[\s-1ARG2\s0] will contain the
numeric and string versions of $!, respectively.
.PP
Depending on the nature of the error and the type of client, it may be
useful to reconnect from the ConnectError callback.
.PP
.Vb 10
\&  ConnectError => sub {
\&    my ($operation, $error_number, $error_string) = @_[ARG0..ARG2];
\&    warn "$operation error $error_number occurred: $error_string";
\&    if (error_is_recoverable($error_number)) {
\&      $_[KERNEL]\->delay( reconnect => 60 );
\&    }
\&    else {
\&      $_[KERNEL]\->yield("shutdown");
\&    }
\&  },
.Ve
.PP
POE::Component::Client::TCP will shut down after ConnectError if a
reconnect isn't requested.
.PP
Connected
.IX Subsection "Connected"
.PP
Connections are asynchronously set up and may take some time to
complete.  \f(CW\*(C`Connected\*(C'\fR is an optional callback that notifies a
program when the connection has finally been made.
.PP
This is an advisory callback that occurs after a POE::Wheel::ReadWrite
object has already been created.  Programs should not need to create
their own.
.PP
\&\f(CW\*(C`Connected\*(C'\fR is called in response to POE::Wheel::SocketFactory's
SuccessEvent.  In addition to the usual \s-1POE\s0 event parameters, it
includes a copy of the established socket handle in  \f(CW$_\fR[\s-1ARG0\s0].
POE::Component::Client::TCP will manage the socket, so an application
should rarely need to save a copy of it.  \f(CW$_\fR[\s-1ARG1\s0] and \f(CW$_\fR[\s-1ARG2\s0]
contain the remote address and port as returned from \fIgetpeername()\fR.
.PP
.Vb 4
\&  Connected => {
\&    my ($socket, $peer_addr, $peer_port) = @_[ARG0, ARG1, ARG2];
\&    # ...
\&  }
.Ve
.PP
See \*(L"PreConnect\*(R" to modify the socket before it's given to
POE::Wheel::ReadWrite.
.PP
ConnectTimeout
.IX Subsection "ConnectTimeout"
.PP
\&\f(CW\*(C`ConnectTimeout\*(C'\fR is the maximum number of seconds to wait for a
connection to be established.  If it is omitted, Client::TCP relies on
the operating system to abort stalled \fIconnect()\fR calls.
.PP
The application will be notified of a timeout via the ConnectError
callback.  In the case of a timeout, \f(CW$_\fR[\s-1ARG0\s0] will contain \*(L"connect\*(R",
and \f(CW$_\fR[\s-1ARG1\s0] and \f(CW$_\fR[\s-1ARG2\s0] will contain the numeric and string
representations of the \s-1ETIMEDOUT\s0 error.
.PP
Domain
.IX Subsection "Domain"
.PP
\&\f(CW\*(C`Domain\*(C'\fR sets the address or protocol family within which to operate.
The \f(CW\*(C`Domain\*(C'\fR may be any value that POE::Wheel::SocketFactory
supports.  \s-1AF_INET\s0 (Internet address space) is used by default.
.PP
Use \s-1AF_INET6\s0 for IPv6 support.  This constant is exported by Socket6,
which must be loaded \fBbefore\fR POE::Component::Client::TCP.
.PP
RemoteAddress
.IX Subsection "RemoteAddress"
.PP
\&\f(CW\*(C`RemoteAddress\*(C'\fR contains the address of the server to connect to.  It
is required and may contain a host name (\*(L"poe.perl.org\*(R"), a dot\- or
colon-separated numeric address (depending on the Domain), or a packed
socket address.  Pretty much anything POE::Wheel::SocketFactory's
RemoteAddress parameter does.
.PP
RemotePort
.IX Subsection "RemotePort"
.PP
\&\f(CW\*(C`RemotePort\*(C'\fR contains the port of the server to connect to.  It is
required and may be a service name (\*(L"echo\*(R") or number (7).
.PP
\fIPOE::Wheel::ReadWrite Constructor Parameters\fR
.IX Subsection "POE::Wheel::ReadWrite Constructor Parameters"
.PP
Parameters in this section control configuration of the client's
POE::Wheel::ReadWrite object.
.PP
Disconnected
.IX Subsection "Disconnected"
.PP
\&\f(CW\*(C`Disconnected\*(C'\fR is an optional callback to notify a program that an
established socket has been disconnected.  It includes no special
parameters.
.PP
It may be useful to reconnect from the Disconnected callback, in the
case of \s-1MUD\s0 bots or long-running services.  For example:
.PP
.Vb 3
\&  Disconnected => sub {
\&    $_[KERNEL]\->delay( reconnect => 60 );
\&  },
.Ve
.PP
The component will shut down if the connection ceases without being
reconnected.
.PP
Filter
.IX Subsection "Filter"
.PP
\&\f(CW\*(C`Filter\*(C'\fR specifies the type of POE::Filter object that will parse
input from and serialize output to a server.  It may either be a
scalar, an array reference, or a POE::Filter object.
.PP
If \f(CW\*(C`Filter\*(C'\fR is a scalar, it will be expected to contain a POE::Filter
class name:
.PP
.Vb 1
\&  Filter => "POE::Filter::Line",
.Ve
.PP
\&\f(CW\*(C`Filter\*(C'\fR is optional.  In most cases, the default \*(L"POE::Filter::Line\*(R"
is fine.
.PP
If \f(CW\*(C`Filter\*(C'\fR is an array reference, the first item in the array will
be treated as a POE::Filter class name.  The remaining items will be
passed to the filter's constructor.  In this example, the vertical bar
will be used as POE::Filter::Line's record terminator:
.PP
.Vb 1
\&  Filter => [ "POE::Filter::Line", Literal => "|" ],
.Ve
.PP
If it is an object, it will be cloned every time the client connects:
.PP
.Vb 1
\&  Filter => POE::Filter::Line\->new(Literal => "|"),
.Ve
.PP
Be sure to \f(CW\*(C`use\*(C'\fR the appropriate POE::Filter subclass when specifying
a \f(CW\*(C`Filter\*(C'\fR other than the default.
.PP
ServerError
.IX Subsection "ServerError"
.PP
\&\f(CW\*(C`ServerError\*(C'\fR is an optional callback that will be invoked when an
established server connection has encountered some kind of error.  It
is triggered by POE::Wheel::ReadWrite's ErrorEvent.  By default, the
component will log any errors to \s-1STDERR\s0.  This may be suppressed by
defining a quieter ServerError callback.
.PP
As with \f(CW\*(C`ConnectError\*(C'\fR, it is invoked with the customary error
parameters:  \f(CW$_\fR[\s-1ARG0\s0] will contain the name of the operation that
failed.  \f(CW$_\fR[\s-1ARG1\s0] and \f(CW$_\fR[\s-1ARG2\s0] will hold the numeric and string forms
of $!, respectively.
.PP
Components usually disconnect on error.  POE::Component::Client::TCP
will shut down if the socket disconnects without being reconnected.
.PP
ServerFlushed
.IX Subsection "ServerFlushed"
.PP
\&\f(CW\*(C`ServerFlushed\*(C'\fR is an optional callback to notify a program that
ReadWrite's output buffers have completely flushed.  It has no special
parameters.
.PP
The component will shut down after a server flush if \f(CW$heap\fR\->{shutdown}
is set.
.PP
ServerInput
.IX Subsection "ServerInput"
.PP
\&\f(CW\*(C`ServerInput\*(C'\fR is a required callback.  It is called for each fully
parsed input record received by POE::Wheel::ReadWrite.  \f(CW$_\fR[\s-1ARG0\s0]
contains the input record, the format of which is determined by the
\&\f(CW\*(C`Filter\*(C'\fR constructor parameter.
.PP
\&\f(CW\*(C`SeverInput\*(C'\fR will stop being called when \f(CW$_\fR[\s-1HEAP\s0]{shutdown} is true.
The most reliable way to set the \*(L"shutdown\*(R" member is to call
\&\f(CW$_\fR[\s-1KERNEL\s0]\->yield(\*(L"shutdown\*(R").
.SH "Public Events"
.IX Header "Public Events"
POE::Component::Client::TCP handles a small number of public \*(L"command\*(R"
messages.  These may be posted into the client from an external
session, or yielded from within the client.
.SS "connect"
.IX Subsection "connect"
The \f(CW\*(C`connect\*(C'\fR event causes POE::Component::Client::TCP to begin
connecting to a server.  It optionally includes a new RemoteHost and
RemotePort, both of which will be used for subsequent reconnections.
.PP
.Vb 1
\&  $_[KERNEL]\->post(alias => connect => "127.0.0.1", 80);
.Ve
.PP
If the client is already connected to a server, it will disconnect
immediately before beginning the new connection procedure.  Buffered
input and output will be lost.
.SS "reconnect"
.IX Subsection "reconnect"
The \f(CW\*(C`reconnect\*(C'\fR command causes POE::Component::Client::TCP to
immediately disconnect its current connection and begin reconnecting
to its most recently set RemoteHost and RemotePort.  Any buffered
input and output will be lost.
.SS "shutdown"
.IX Subsection "shutdown"
The \f(CW\*(C`shutdown\*(C'\fR command tells POE::Component::Client::TCP to flush its
buffers, disconnect, and begin \s-1DESTROY\s0 procedures.
.PP
All input will be discarded after receipt of \*(L"shutdown\*(R".  All pending
output will be written to the server socket before disconnecting and
destructing.
.SH "Reserved Heap Members"
.IX Header "Reserved Heap Members"
POE::Component::Client::TCP requires some heap space for its own
bookkeeping.  The following members are used and should be used as
directed, or with care.
.PP
This sample input handler is an example of most reserved heap members:
.PP
.Vb 3
\&  sub handle_input {
\&    # Pending input from when we were connected.
\&    return unless $_[HEAP]{connected};
\&
\&    # We\*(Aqve been shut down.
\&    return if $_[HEAP]{shutdown};
\&
\&    my $input = $_[ARG0];
\&    $_[HEAP]{server}\->put("you sent: $input");
\&  }
.Ve
.SS "server"
.IX Subsection "server"
The read-only \f(CW\*(C`server\*(C'\fR heap member contains the POE::Wheel object
used to connect to or talk with the server.  While the component is
connecting, \f(CW\*(C`server\*(C'\fR will be a POE::Wheel::SocketFactory object.  After
the connection has been made, \f(CW\*(C`server\*(C'\fR is replaced with a
POE::Wheel::ReadWrite object.
.PP
The most reliable way to avoid prematurely using \f(CW\*(C`server\*(C'\fR is to first
check the \f(CW\*(C`connected\*(C'\fR reserved heap member.  See the example above.
.SS "shutdown"
.IX Subsection "shutdown"
\&\f(CW\*(C`shutdown\*(C'\fR is a read-only flag that tells the component it's shutting
down.  It should only be by the \f(CW\*(C`shutdown\*(C'\fR event, which does other
cleanup.
.PP
\&\f(CW\*(C`shutdown\*(C'\fR may be checked to avoid starting new work during a
client's shutting-down procedure.  See the example above.
.SS "connected"
.IX Subsection "connected"
\&\f(CW\*(C`connected\*(C'\fR is a read-only flag that indicates whether the component
is currently connected.
.SS "shutdown_on_error"
.IX Subsection "shutdown_on_error"
\&\f(CW\*(C`shutdown_on_error\*(C'\fR is a read-only flag that governs the component's
shutdown-on-error behavior.  When true, POE::Component::Client::TCP
will automatically shutdown when it encounters an error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1SEE\s0 \s-1ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.PP
POE::Component::Server::TCP is the server-side counterpart to this
module.
.PP
This component uses and exposes features from POE::Filter,
POE::Wheel::SocketFactory, and POE::Wheel::ReadWrite.
.PP
See \*(L"\s-1SYNOPSIS\s0\*(R" in POE::Wheel::SocketFactory for a more efficient but
lower-level way to create clients and servers.
.SH "CAVEATS"
.IX Header "CAVEATS"
This looks nothing like what Ann envisioned.
.PP
POE::Component::Client::TCP is a generic client.  As such, it's not
tuned for any particular task.  While it handles the common cases well
and with a minimum of code, it may not be suitable for everything.
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
POE::Component::Client::TCP is Copyright 2001\-2009 by Rocco Caputo.
All rights are reserved.  POE::Component::Client::TCP is free
software, and it may be redistributed and/or modified under the same
terms as Perl itself.
.PP
POE::Component::Client::TCP is based on code, used with permission,
from Ann Barcomb <kudra@domaintje.com>.
.PP
POE::Component::Client::TCP is based on code, used with permission,
from Jos Boumans <kane@cpan.org>.
