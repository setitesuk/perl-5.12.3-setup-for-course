.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Symbol::Util 3"
.TH Symbol::Util 3 "2009-11-29" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Symbol::Util \- Additional utils for Perl symbols manipulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Symbol::Util \*(Aq:all\*(Aq;
\&
\&  my $caller = caller;
\&  *{ fetch_glob("${caller}::foo") } = sub { "this is foo" };
\&  my $coderef = fetch_glob("${caller}::bar", "CODE");
\&  sub baz { 42; }
\&  export_glob($caller, "baz");
\&
\&  print join "\en", keys %{ stash("main") };
\&
\&  delete_glob("${caller}::foo", "CODE");
\&
\&  use constant PI => 3.14159265;
\&  delete_sub "PI";   # remove constant from public API
\&
\&  require YAML;
\&  export_package(_\|_PACKAGE_\|_, "YAML", "Dump");   # import YAML::Dump
\&  unexport_package(_\|_PACKAGE, "YAML");   # remove imported symbols
\&
\&  no Symbol::Util;   # clean all symbols imported from Symbol::Util
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a set of additional functions useful for Perl
symbols manipulation.
.PP
\&\f(CW\*(C`stash\*(C'\fR and \f(CW\*(C`fetch_glob\*(C'\fR functions gets stash or glob without need to use
\&\f(CW\*(C`no strict \*(Aqrefs\*(Aq\*(C'\fR.
.PP
\&\f(CW\*(C`delete_glob\*(C'\fR function allows to delete specific slot of
symbol name without deleting others.
.PP
\&\f(CW\*(C`delete_sub\*(C'\fR removes the symbol from class \s-1API\s0.  This symbol won't be
available as an object method.
.PP
\&\f(CW\*(C`export_package\*(C'\fR works like Exporter module and allows to export symbols
from one package to other.
.PP
\&\f(CW\*(C`unexport_package\*(C'\fR allows to delete previously exported symbols.
.SH "IMPORTS"
.IX Header "IMPORTS"
By default, the class does not export its symbols.
.IP "use Symbol::Util ':all';" 4
.IX Item "use Symbol::Util ':all';"
Imports all available symbols.
.IP "no Symbol::Util;" 4
.IX Item "no Symbol::Util;"
Deletes all imported symbols from caller name space.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "stash( \fIname\fR : Str ) : HashRef" 4
.IX Item "stash( name : Str ) : HashRef"
Returns a refernce to the stash for the specified name.  If the stash does not
already exists it will be created.  The name of the stash does not include the
\&\f(CW\*(C`::\*(C'\fR at the end.  It is safe to use this function with \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR.
.Sp
This function is taken from Kurila, a dialect of Perl.
.Sp
.Vb 1
\&  print join "\en", keys %{ Symbol::stash("main") };
.Ve
.IP "fetch_glob( \fIname\fR : Str ) : GlobRef" 4
.IX Item "fetch_glob( name : Str ) : GlobRef"
.PD 0
.IP "fetch_glob( \fIname\fR : Str, \fIslot\fR : Str ) : Ref" 4
.IX Item "fetch_glob( name : Str, slot : Str ) : Ref"
.PD
Returns a reference to the glob for the specified symbol name.  If the
symbol does not already exists it will be created.  If the symbol name is
unqualified it will be looked up in the calling package.  It is safe to use
this function with \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR.
.Sp
If \fIslot\fR argument is defined and this slot has defined value, reference to
its value is returned.  The \fIslot\fR argument can be one of the following
strings: \f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, \f(CW\*(C`IO\*(C'\fR, \f(CW\*(C`FORMAT\*(C'\fR).
.Sp
This function is taken from Kurila, a dialect of Perl.
.Sp
.Vb 3
\&  my $caller = caller;
\&  *{ fetch_glob("${caller}::foo") } = sub { "this is foo" };
\&  my $coderef = fetch_glob("${caller}::foo", "CODE");
.Ve
.IP "list_glob_slots( \fIname\fR ) : Maybe[Array]" 4
.IX Item "list_glob_slots( name ) : Maybe[Array]"
Returns a list of slot names for glob with specified name which have defined
value.  If the glob is undefined, the \f(CW\*(C`undef\*(C'\fR value is returned.  If the glob
is defined and has no defined slots, the empty list is returned.
.Sp
The \f(CW\*(C`SCALAR\*(C'\fR slot is used only if it contains defined value.
.Sp
.Vb 1
\&  print join ",", list_glob_slots("foo");
.Ve
.IP "export_glob( \fItarget\fR, \fIname\fR : Str ) : GlobRef" 4
.IX Item "export_glob( target, name : Str ) : GlobRef"
.PD 0
.IP "export_glob( \fItarget\fR, \fIname\fR : Str, \fIslots\fR : Array ) : Ref" 4
.IX Item "export_glob( target, name : Str, slots : Array ) : Ref"
.PD
Exports a glob \fIname\fR to the \fItarget\fR package.  Optionally exports only
specified slots of the glob.
.Sp
.Vb 5
\&  sub my_function { ... };
\&  sub import {
\&      my $caller = caller;
\&      export_glob($caller, "my_function");
\&  }
.Ve
.IP "delete_glob( \fIname\fR : Str, \fIslots\fR : Array[Str] ) : Maybe[GlobRef]" 4
.IX Item "delete_glob( name : Str, slots : Array[Str] ) : Maybe[GlobRef]"
Deletes the specified symbol name if \fIslots\fR are not specified, or deletes
the specified slots in the symbol name (could be one or more of the following
strings: \f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, \f(CW\*(C`IO\*(C'\fR, \f(CW\*(C`FORMAT\*(C'\fR).
.Sp
Function returns the glob reference if there are any slots defined.
.Sp
.Vb 2
\&  our $FOO = 1;
\&  sub FOO { "bar" };
\&
\&  delete_glob("FOO", "CODE");
\&
\&  print $FOO;  # prints "1"
\&  FOO();       # error: sub not found
.Ve
.IP "delete_sub( \fIname\fR : Str ) : Maybe[GlobRef]" 4
.IX Item "delete_sub( name : Str ) : Maybe[GlobRef]"
Deletes (or hides) the specified subroutine name from class \s-1API\s0.  It means
that this subroutine will be no longer available as the class method.  The
purpose of this function is the same as namespace::clean pragma has.
.Sp
Function returns the glob reference if there are any other slots still defined
than <\s-1CODE\s0> slot.
.Sp
.Vb 1
\&  package My::Class;
\&
\&  use constant PI => 3.14159265;
\&
\&  use Symbol::Util \*(Aqdelete_sub\*(Aq;
\&  delete_sub "PI";   # remove constant from public API
\&  no Symbol::Util;   # remove also Symbol::Util::* from public API
\&
\&  sub area {
\&      my ($self, $r) = @_;
\&      return PI * $r ** 2
\&  }
\&
\&  print My::Class\->area(2);   # prints 12.5663706
\&  print My::Class\->PI;        # can\*(Aqt locate object method
.Ve
.IP "export_package( \fItarget\fR : Str, \fIpackage\fR : Str, \fInames\fR : Array[Str] ) : Bool" 4
.IX Item "export_package( target : Str, package : Str, names : Array[Str] ) : Bool"
.PD 0
.IP "export_package( \fItarget\fR : Str, \fIpackage\fR : Str, \fIspec\fR : HashRef, \fInames\fR : Array[Str] ) : Bool" 4
.IX Item "export_package( target : Str, package : Str, spec : HashRef, names : Array[Str] ) : Bool"
.PD
Exports symbols from \fIpackage\fR to \fItarget\fR.  If \fIspec\fR is defined as hash
reference, it contains the specification for exporter.  Otherwise the standard
global variables of \fIpackage\fR are used (\f(CW@EXPORT\fR, \f(CW@EXPORT_OK\fR and
\&\f(CW%EXPORT_TAGS\fR) to build the specification for exporter.  The optional list
of \fInames\fR defines an import list.
.Sp
The \fIspec\fR is a reference to hash with following keys:
.RS 4
.IP "\s-1EXPORT\s0" 4
.IX Item "EXPORT"
Contains the list of default imports.  It is the same as \f(CW@EXPORT\fR variable.
.IP "\s-1OK\s0" 4
.IX Item "OK"
Contains the list of allowed imports.  It is the same as \f(CW@EXPORT_OK\fR
variable.
.IP "\s-1TAGS\s0" 4
.IX Item "TAGS"
Contains the hash with tags.  It is the same as \f(CW%EXPORT_TAGS\fR variable.
.RE
.RS 4
.Sp
See Exporter documentation for explanation of these global variables and
list of \fInames\fR.
.Sp
The \f(CW\*(C`export_package\*(C'\fR function can export symbols from an external package to
an external package.  This function can also be used as a helper in \f(CW\*(C`import\*(C'\fR
method.
.Sp
.Vb 9
\&  package My::Package;
\&  sub myfunc { };
\&  sub import {
\&      my ($package, @names) = @_;
\&      my $caller = caller();
\&      return export_package($caller, $package, {
\&          OK => [ qw( myfunc ) ],
\&      }, @names);
\&  };
.Ve
.Sp
All exported symbols are tracked and later can be removed with
\&\f(CW\*(C`unexport_package\*(C'\fR function.
.Sp
The function returns true value if there were no errors.
.RE
.IP "unexport_package( \fItarget\fR, \fIpackage\fR ) : Bool" 4
.IX Item "unexport_package( target, package ) : Bool"
Deletes symbols previously exported from \fIpackage\fR to \fItarget\fR with
\&\f(CW\*(C`export_package\*(C'\fR function.  If the symbol was \f(CW\*(C`CODE\*(C'\fR reference it is deleted
with \f(CW\*(C`delete_sub\*(C'\fR function.  Otherwise it is deleted with \f(CW\*(C`delete_glob\*(C'\fR
function with proper slot as an argument.
.Sp
Deleting with \f(CW\*(C`delete_sub\*(C'\fR function means that this symbol is not available
via class \s-1API\s0 as an object method.
.Sp
.Vb 3
\&  require YAML;
\&  export_package(_\|_PACKAGE_\|_, "YAML", "dump");
\&  unexport_package(_\|_PACKAGE_\|_, "YAML");
.Ve
.Sp
This function can be used as a helper in \f(CW\*(C`unimport\*(C'\fR method.
.Sp
.Vb 6
\&  package My::Package;
\&  sub unimport {
\&      my ($package, @names) = @_;
\&      my $caller = caller();
\&      return unexport_package($caller, $package);
\&  };
\&
\&  package main;
\&  use My::Package qw(something);
\&  no My::Package;
\&  main\->something;   # Can\*(Aqt locate object method
.Ve
.Sp
The function returns true value if there were no errors.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Symbol, Sub::Delete, namespace::clean, Exporter.
.SH "BUGS"
.IX Header "BUGS"
\&\f(CW\*(C`fetch_glob\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR value if \f(CW\*(C`SCALAR\*(C'\fR slot contains \f(CW\*(C`undef\*(C'\fR value.
.PP
\&\f(CW\*(C`delete_glob\*(C'\fR deletes \f(CW\*(C`SCALAR\*(C'\fR slot if it exists and contains \f(CW\*(C`undef\*(C'\fR
value.
.PP
\&\f(CW\*(C`delete_glob\*(C'\fR always deletes \f(CW\*(C`FORMAT\*(C'\fR slot.
.PP
If you find the bug or want to implement new features, please report it at
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Symbol\-Util <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Symbol-Util>
.SH "AUTHOR"
.IX Header "AUTHOR"
Piotr Roszatycki <dexter@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2009 by Piotr Roszatycki <dexter@cpan.org>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
