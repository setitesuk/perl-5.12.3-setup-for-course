.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MooseX::Workers::Engine 3"
.TH MooseX::Workers::Engine 3 "2010-11-15" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Workers::Engine \- Provide the workhorse to MooseX::Workers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package MooseX::Workers;
\&
\&    has Engine => (
\&        isa      => \*(AqMooseX::Workers::Engine\*(Aq,
\&        is       => \*(Aqro\*(Aq,
\&        lazy     => 1,
\&        required => 1,
\&        default  => sub { MooseX::Workers::Engine\->new( visitor => $_[0] ) },
\&        handles  => [
\&            qw(
\&              max_workers
\&              has_workers
\&              num_workers
\&              put_worker
\&              kill_worker
\&              )
\&        ],
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
MooseX::Workers::Engine provides the main functionality 
to MooseX::Workers. It wraps a POE::Session and as many POE::Wheel::Run
objects as it needs.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "visitor" 4
.IX Item "visitor"
Hold a reference to our main object so we can use the callbacks on it.
.IP "max_workers" 4
.IX Item "max_workers"
An Integer specifying the maxium number of workers we have.
.IP "workers" 4
.IX Item "workers"
An ArrayRef of POE::Wheel::Run objects that are our workers.
.IP "session" 4
.IX Item "session"
Contains the POE::Session that controls the workers.
.SH "METHODS"
.IX Header "METHODS"
.IP "yield" 4
.IX Item "yield"
Helper method to post events to our internal manager session.
.IP "call" 4
.IX Item "call"
Helper method to call events to our internal manager session. 
This is synchronous and will block incoming data from the children 
if it takes too long to return.
.IP "set_worker($key)" 4
.IX Item "set_worker($key)"
Set the worker at \f(CW$key\fR
.IP "get_worker($key)" 4
.IX Item "get_worker($key)"
Retrieve the worker at \f(CW$key\fR
.IP "delete_worker($key)" 4
.IX Item "delete_worker($key)"
Remove the worker atx \f(CW$key\fR
.IP "has_workers" 4
.IX Item "has_workers"
Check to see if we have *any* workers currently. This is delegated to the MooseX::Workers::Engine object.
.IP "num_workers" 4
.IX Item "num_workers"
Return the current number of workers. This is delegated to the MooseX::Workers::Engine object.
.IP "has_manager" 4
.IX Item "has_manager"
Check to see if we have a manager session.
.IP "remove_manager" 4
.IX Item "remove_manager"
Remove the manager session.
.IP "meta" 4
.IX Item "meta"
The Metaclass for MooseX::Workers::Engine see Moose's documentation.
.SH "EVENTS"
.IX Header "EVENTS"
.IP "add_worker ($command)" 4
.IX Item "add_worker ($command)"
Create a POE::Wheel::Run object to handle \f(CW$command\fR. If \f(CW$command\fR holds a scalar, it will be executed as exec($scalar). 
Shell metacharacters will be expanded in this form. If \f(CW$command\fR holds an array reference, 
it will executed as exec(@$array). This form of \fIexec()\fR doesn't expand shell metacharacters. 
If \f(CW$command\fR holds a code reference, it will be called in the forked child process, and then 
the child will exit.
.Sp
See POE::Wheel::Run for more details.
.SH "INTERFACE"
.IX Header "INTERFACE"
MooseX::Worker::Engine fires the following callbacks to its visitor object:
.IP "worker_manager_start" 4
.IX Item "worker_manager_start"
Called when the managing session is started.
.IP "worker_manager_stop" 4
.IX Item "worker_manager_stop"
Called when the managing session stops.
.IP "max_workers_reached" 4
.IX Item "max_workers_reached"
Called when we reach the maximum number of workers.
.IP "worker_stdout" 4
.IX Item "worker_stdout"
Called when a child prints to \s-1STDOUT\s0.
.IP "worker_stderr" 4
.IX Item "worker_stderr"
Called when a child prints to \s-1STDERR\s0.
.IP "worker_error" 4
.IX Item "worker_error"
Called when there is an error condition detected with the child.
.IP "worker_done" 4
.IX Item "worker_done"
Called when a worker completes \f(CW$command\fR.
.IP "worker_started" 4
.IX Item "worker_started"
Called when a worker starts \f(CW$command\fR.
.ie n .IP "sig_child($PID, $ret)" 4
.el .IP "sig_child($PID, \f(CW$ret\fR)" 4
.IX Item "sig_child($PID, $ret)"
Called when the managing session receives a \s-1SIG\s0 \s-1CHLD\s0 event.
.IP "sig_*" 4
.IX Item "sig_*"
Called when the underlying \s-1POE\s0 Kernel receives a signal; this is not limited to
\&\s-1OS\s0 signals (ie. what you'd usually handle in Perl's \f(CW%SIG\fR) so will also accept
arbitrary \s-1POE\s0 signals (sent via POE::Kernel\->signal), but does exclude
\&\s-1SIGCHLD/SIGCHILD\s0, which is instead handled by sig_child above.
.Sp
These interface methods are automatically inserted when MooseX::Worker::Engine
detects that the visitor object contains any methods beginning with sig_.
Signals are case-sensitive, so if you wish to handle a \s-1TERM\s0 signal, you must
define a \fIsig_TERM()\fR method.  Note also that this action is performed upon
MooseX::Worker::Engine startup, so any run-time modification of the visitor
object is not likely to be detected.
