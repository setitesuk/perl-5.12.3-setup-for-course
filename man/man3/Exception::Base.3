.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Exception::Base 3"
.TH Exception::Base 3 "2010-10-01" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Exception::Base \- Lightweight exceptions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&  # Use module and create needed exceptions
\&  use Exception::Base
\&     \*(AqException::Runtime\*(Aq,              # create new module
\&     \*(AqException::System\*(Aq,               # load existing module
\&     \*(AqException::IO\*(Aq,          => {
\&         isa => \*(AqException::System\*(Aq },  # create new based on existing
\&     \*(AqException::FileNotFound\*(Aq => {
\&         isa => \*(AqException::IO\*(Aq,        # create new based on previous
\&         message => \*(AqFile not found\*(Aq,   # override default message
\&         has => [ \*(Aqfilename\*(Aq ],         # define new rw attribute
\&         string_attributes => [ \*(Aqmessage\*(Aq, \*(Aqfilename\*(Aq ],
\&     };                                 # output message and filename
\&
\&  # eval is used as "try" block
\&  eval {
\&    open my $file, \*(Aq/etc/passwd\*(Aq
\&      or Exception::FileNotFound\->throw(
\&            message=>\*(AqSomething wrong\*(Aq,
\&            filename=>\*(Aq/etc/passwd\*(Aq);
\&  };
\&  # syntax for Perl >= 5.10
\&  use feature \*(Aqswitch\*(Aq;
\&  if ($@) {
\&    given (my $e = Exception::Base\->catch) {
\&      when ($e\->isa(\*(AqException::IO\*(Aq)) { warn "IO problem"; }
\&      when ($e\->isa(\*(AqException::Eval\*(Aq)) { warn "eval died"; }
\&      when ($e\->isa(\*(AqException::Runtime\*(Aq)) { warn "some runtime was caught"; }
\&      when ($e\->matches({value=>9})) { warn "something happened"; }
\&      when ($e\->matches(qr/^Error/)) { warn "some error based on regex"; }
\&      default { $e\->throw; } # rethrow the exception
\&    }
\&  }
\&  # standard syntax for older Perl
\&  if ($@) {
\&    my $e = Exception::Base\->catch;   # convert $@ into exception
\&    if ($e\->isa(\*(AqException::IO\*(Aq)) { warn "IO problem"; }
\&    elsif ($e\->isa(\*(AqException::Eval\*(Aq)) { warn "eval died"; }
\&    elsif ($e\->isa(\*(AqException::Runtime\*(Aq)) { warn "some runtime was caught"; }
\&    elsif ($e\->matches({value=>9})) { warn "something happened"; }
\&    elsif ($e\->matches(qr/^Error/)) { warn "some error based on regex"; }
\&    else { $e\->throw; } # rethrow the exception
\&  }
\&
\&  # $@ has to be recovered ASAP!
\&  eval { die "this die will be caught" };
\&  my $e = Exception::Base\->catch;
\&  eval { die "this die will be ignored" };
\&  if ($e) {
\&     (...)
\&  }
\&
\&  # the exception can be thrown later
\&  my $e = Exception::Base\->new;
\&  # (...)
\&  $e\->throw;
\&
\&  # ignore our package in stack trace
\&  package My::Package;
\&  use Exception::Base \*(Aq+ignore_package\*(Aq => _\|_PACKAGE_\|_;
\&
\&  # define new exception in separate module
\&  package Exception::My;
\&  use Exception::Base (_\|_PACKAGE_\|_) => {
\&      has => [\*(Aqmyattr\*(Aq],
\&  };
\&
\&  # run Perl with changed verbosity for debugging purposes
\&  $ perl \-MException::Base=verbosity,4 script.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements a fully \s-1OO\s0 exception mechanism similar to
Exception::Class or Class::Throwable.  It provides a simple interface
allowing programmers to declare exception classes.  These classes can be
thrown and caught.  Each uncaught exception prints full stack trace if the
default verbosity is uppered for debugging purposes.
.PP
The features of \f(CW\*(C`Exception::Base\*(C'\fR:
.IP "\(bu" 2
fast implementation of the exception class
.IP "\(bu" 2
fully \s-1OO\s0 without closures and source code filtering
.IP "\(bu" 2
does not mess with \f(CW$SIG{_\|_DIE_\|_}\fR and \f(CW$SIG{_\|_WARN_\|_}\fR
.IP "\(bu" 2
no external run-time modules dependencies, requires core Perl modules only
.IP "\(bu" 2
the default behavior of exception class can be changed globally or just for
the thrown exception
.IP "\(bu" 2
matching the exception by class, message or other attributes
.IP "\(bu" 2
matching with string, regex or closure function
.IP "\(bu" 2
creating automatically the derived exception classes (\*(L"use\*(R" in perlfunc
interface)
.IP "\(bu" 2
easly expendable, see Exception::System class for example
.IP "\(bu" 2
prints just an error message or dumps full stack trace
.IP "\(bu" 2
can propagate (rethrow) an exception
.IP "\(bu" 2
can ignore some packages for stack trace output
.IP "\(bu" 2
some defaults (i.e. verbosity) can be different for different exceptions
.SH "OVERLOADS"
.IX Header "OVERLOADS"
.IP "Boolean context" 4
.IX Item "Boolean context"
True value.  See \f(CW\*(C`to_bool\*(C'\fR method.
.Sp
.Vb 4
\&  eval { Exception::Base\->throw( message=>"Message", value=>123 ) };
\&  if ($@) {
\&     # the exception object is always true
\&  }
.Ve
.IP "Numeric context" 4
.IX Item "Numeric context"
Content of attribute pointed by \f(CW\*(C`numeric_attribute\*(C'\fR attribute.  See
\&\f(CW\*(C`to_number\*(C'\fR method.
.Sp
.Vb 2
\&  eval { Exception::Base\->throw( message=>"Message", value=>123 ) };
\&  print 0+$@;           # 123
.Ve
.IP "String context" 4
.IX Item "String context"
Content of attribute which is combined from \f(CW\*(C`string_attributes\*(C'\fR attributes
with additional informations, depended on \f(CW\*(C`verbosity\*(C'\fR setting.  See
\&\f(CW\*(C`to_string\*(C'\fR method.
.Sp
.Vb 2
\&  eval { Exception::Base\->throw( message=>"Message", value=>123 ) };
\&  print "$@";           # "Message at \-e line 1.\en"
.Ve
.ie n .IP """~~""" 4
.el .IP "``~~''" 4
.IX Item "~~"
Smart matching operator.  See \f(CW\*(C`matches\*(C'\fR method.
.Sp
.Vb 6
\&  eval { Exception::Base\->throw( message=>"Message", value=>123 ) };
\&  print "Message" ~~ $@;                          # 1
\&  print qr/message/i ~~ $@;                       # 1
\&  print [\*(AqException::Base\*(Aq] ~~ $@;                # 1
\&  print 123 ~~ $@;                                # 1
\&  print {message=>"Message", value=>123} ~~ $@;   # 1
.Ve
.Sp
Warning: The smart operator requires that the exception object is a second
argument.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.IP "\s-1ATTRS\s0" 4
.IX Item "ATTRS"
Declaration of class attributes as reference to hash.
.Sp
The attributes are listed as \fIname\fR => {\fIproperties\fR}, where \fIproperties\fR is a
list of attribute properties:
.RS 4
.IP "is" 4
.IX Item "is"
Can be 'rw' for read-write attributes or 'ro' for read-only attributes.  The
attribute is read-only and does not have an accessor created if 'is' property
is missed.
.IP "default" 4
.IX Item "default"
Optional property with the default value if the attribute value is not
defined.
.RE
.RS 4
.Sp
The read-write attributes can be set with \f(CW\*(C`new\*(C'\fR constructor.  Read-only
attributes and unknown attributes are ignored.
.Sp
The constant have to be defined in derived class if it brings additional
attributes.
.Sp
.Vb 2
\&  package Exception::My;
\&  use base \*(AqException::Base\*(Aq;
\&
\&  # Define new class attributes
\&  use constant ATTRS => {
\&    %{Exception::Base\->ATTRS},       # base\*(Aqs attributes have to be first
\&    readonly  => { is=>\*(Aqro\*(Aq },                   # new ro attribute
\&    readwrite => { is=>\*(Aqrw\*(Aq, default=>\*(Aqblah\*(Aq },  # new rw attribute
\&  };
\&
\&  package main;
\&  use Exception::Base \*(Aq:all\*(Aq;
\&  eval {
\&    Exception::My\->throw( readwrite => 2 );
\&  };
\&  if ($@) {
\&    my $e = Exception::Base\->catch;
\&    print $e\->readwrite;                # = 2
\&    print $e\->defaults\->{readwrite};    # = "blah"
\&  }
.Ve
.RE
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Class attributes are implemented as values of blessed hash.  The attributes
are also available as accessors methods.
.IP "message (rw, default: 'Unknown exception')" 4
.IX Item "message (rw, default: 'Unknown exception')"
Contains the message of the exception.  It is the part of the string
representing the exception object.
.Sp
.Vb 2
\&  eval { Exception::Base\->throw( message=>"Message" ); };
\&  print $@\->message if $@;
.Ve
.Sp
It can also be an array reference of strings and then the \*(L"perlfunc\*(R" in sprintf
is used to get a message.
.Sp
.Vb 1
\&  Exception::Base\->throw( message => ["%s failed", _\|_PACKAGE_\|_] );
.Ve
.IP "value (rw, default: 0)" 4
.IX Item "value (rw, default: 0)"
Contains the value which represents numeric value of the exception object in
numeric context.
.Sp
.Vb 2
\&  eval { Exception::Base\->throw( value=>2 ); };
\&  print "Error 2" if $@ == 2;
.Ve
.IP "verbosity (rw, default: 2)" 4
.IX Item "verbosity (rw, default: 2)"
Contains the verbosity level of the exception object.  It allows to change the
string representing the exception object.  There are following levels of
verbosity:
.RS 4
.IP "0" 2
Empty string
.IP "1" 2
.IX Item "1"
.Vb 1
\& Message
.Ve
.IP "2" 2
.IX Item "2"
.Vb 1
\& Message at %s line %d.
.Ve
.Sp
The same as the standard output of \fIdie()\fR function.  It doesn't include
\&\*(L"at \f(CW%s\fR line \f(CW%d\fR.\*(R" string if message ends with \f(CW"\en"\fR character.  This is
the default option.
.IP "3" 2
.IX Item "3"
.Vb 4
\& Class: Message at %s line %d
\&         %c_ = %s::%s() called in package %s at %s line %d
\&         ...propagated in package %s at %s line %d.
\& ...
.Ve
.Sp
The output contains full trace of error stack without first \f(CW\*(C`ignore_level\*(C'\fR
lines and those packages which are listed in \f(CW\*(C`ignore_package\*(C'\fR and
\&\f(CW\*(C`ignore_class\*(C'\fR settings.
.IP "4" 2
.IX Item "4"
The output contains full trace of error stack.  In this case the
\&\f(CW\*(C`ignore_level\*(C'\fR, \f(CW\*(C`ignore_package\*(C'\fR and \f(CW\*(C`ignore_class\*(C'\fR settings are meaning
only for first line of exception's message.
.RE
.RS 4
.Sp
If the verbosity is undef, then the default verbosity for exception objects is
used.
.Sp
If the verbosity set with constructor (\f(CW\*(C`new\*(C'\fR or \f(CW\*(C`throw\*(C'\fR) is lower than 3,
the full stack trace won't be collected.
.Sp
If the verbosity is lower than 2, the full system data (time, pid, tid, uid,
euid, gid, egid) won't be collected.
.Sp
This setting can be changed with import interface.
.Sp
.Vb 1
\&  use Exception::Base verbosity => 4;
.Ve
.Sp
It can be also changed for Perl interpreter instance, i.e. for debugging
purposes.
.Sp
.Vb 1
\&  sh$ perl \-MException::Base=verbosity,4 script.pl
.Ve
.RE
.IP "ignore_package (rw)" 4
.IX Item "ignore_package (rw)"
Contains the name (scalar or regexp) or names (as references array) of
packages which are ignored in error stack trace.  It is useful if some package
throws an exception but this module shouldn't be listed in stack trace.
.Sp
.Vb 6
\&  package My::Package;
\&  use Exception::Base;
\&  sub my_function {
\&    do_something() or throw Exception::Base ignore_package=>_\|_PACKAGE_\|_;
\&    throw Exception::Base ignore_package => [ "My", qr/^My::Modules::/ ];
\&  }
.Ve
.Sp
This setting can be changed with import interface.
.Sp
.Vb 1
\&  use Exception::Base ignore_package => _\|_PACKAGE_\|_;
.Ve
.IP "ignore_class (rw)" 4
.IX Item "ignore_class (rw)"
Contains the name (scalar) or names (as references array) of packages which
are base classes for ignored packages in error stack trace.  It means that
some packages will be ignored even the derived class was called.
.Sp
.Vb 3
\&  package My::Package;
\&  use Exception::Base;
\&  Exception::Base\->throw( ignore_class => "My::Base" );
.Ve
.Sp
This setting can be changed with import interface.
.Sp
.Vb 1
\&  use Exception::Base ignore_class => "My::Base";
.Ve
.IP "ignore_level (rw)" 4
.IX Item "ignore_level (rw)"
Contains the number of level on stack trace to ignore.  It is useful if some
package throws an exception but this module shouldn't be listed in stack
trace.  It can be used with or without \fIignore_package\fR attribute.
.Sp
.Vb 5
\&  # Convert warning into exception. The signal handler ignores itself.
\&  use Exception::Base \*(AqException::My::Warning\*(Aq;
\&  $SIG{_\|_WARN_\|_} = sub {
\&    Exception::My::Warning\->throw( message => $_[0], ignore_level => 1 );
\&  };
.Ve
.IP "time (ro)" 4
.IX Item "time (ro)"
Contains the timestamp of the thrown exception.  Collected if the verbosity on
throwing exception was greater than 1.
.Sp
.Vb 2
\&  eval { Exception::Base\->throw( message=>"Message" ); };
\&  print scalar localtime $@\->time;
.Ve
.IP "pid (ro)" 4
.IX Item "pid (ro)"
Contains the \s-1PID\s0 of the Perl process at time of thrown exception.  Collected
if the verbosity on throwing exception was greater than 1.
.Sp
.Vb 2
\&  eval { Exception::Base\->throw( message=>"Message" ); };
\&  kill 10, $@\->pid;
.Ve
.IP "tid (ro)" 4
.IX Item "tid (ro)"
Contains the tid of the thread or undef if threads are not used.  Collected
if the verbosity on throwing exception was greater than 1.
.IP "uid (ro)" 4
.IX Item "uid (ro)"
.PD 0
.IP "euid (ro)" 4
.IX Item "euid (ro)"
.IP "gid (ro)" 4
.IX Item "gid (ro)"
.IP "egid (ro)" 4
.IX Item "egid (ro)"
.PD
Contains the real and effective uid and gid of the Perl process at time of
thrown exception.  Collected if the verbosity on throwing exception was
greater than 1.
.IP "caller_stack (ro)" 4
.IX Item "caller_stack (ro)"
Contains the error stack as array of array with informations about caller
functions.  The first 8 elements of the array's row are the same as first 8
elements of the output of \f(CW\*(C`caller\*(C'\fR function.  Further elements are optional
and are the arguments of called function.  Collected if the verbosity on
throwing exception was greater than 1.  Contains only the first element of
caller stack if the verbosity was lower than 3.
.Sp
If the arguments of called function are references and
\&\f(CW\*(C`Scalar::Util::weaken\*(C'\fR function is available then reference is weakened.
.Sp
.Vb 3
\&  eval { Exception::Base\->throw( message=>"Message" ); };
\&  ($package, $filename, $line, $subroutine, $hasargs, $wantarray,
\&  $evaltext, $is_require, @args) = $@\->caller_stack\->[0];
.Ve
.IP "propagated_stack (ro)" 4
.IX Item "propagated_stack (ro)"
Contains the array of array which is used for generating \*(L"...propagated at\*(R"
message.  The elements of the array's row are the same as first 3 elements of
the output of \f(CW\*(C`caller\*(C'\fR function.
.IP "max_arg_len (rw, default: 64)" 4
.IX Item "max_arg_len (rw, default: 64)"
Contains the maximal length of argument for functions in backtrace output.
Zero means no limit for length.
.Sp
.Vb 2
\&  sub a { Exception::Base\->throw( max_arg_len=>5 ) }
\&  a("123456789");
.Ve
.IP "max_arg_nums (rw, default: 8)" 4
.IX Item "max_arg_nums (rw, default: 8)"
Contains the maximal number of arguments for functions in backtrace output.
Zero means no limit for arguments.
.Sp
.Vb 2
\&  sub a { Exception::Base\->throw( max_arg_nums=>1 ) }
\&  a(1,2,3);
.Ve
.IP "max_eval_len (rw, default: 0)" 4
.IX Item "max_eval_len (rw, default: 0)"
Contains the maximal length of eval strings in backtrace output.  Zero means
no limit for length.
.Sp
.Vb 2
\&  eval "Exception\->throw( max_eval_len=>10 )";
\&  print "$@";
.Ve
.IP "defaults" 4
.IX Item "defaults"
Meta-attribute contains the list of default values.
.Sp
.Vb 4
\&  my $e = Exception::Base\->new;
\&  print defined $e\->{verbosity}
\&    ? $e\->{verbosity}
\&    : $e\->{defaults}\->{verbosity};
.Ve
.IP "default_attribute (default: 'message')" 4
.IX Item "default_attribute (default: 'message')"
Meta-attribute contains the name of the default attribute.  This attribute
will be set for one argument throw method.  This attribute has meaning for
derived classes.
.Sp
.Vb 4
\&  use Exception::Base \*(AqException::My\*(Aq => {
\&      has => \*(Aqmyattr\*(Aq,
\&      default_attribute => \*(Aqmyattr\*(Aq,
\&  };
\&
\&  eval { Exception::My\->throw("string") };
\&  print $@\->myattr;    # "string"
.Ve
.IP "numeric_attribute (default: 'value')" 4
.IX Item "numeric_attribute (default: 'value')"
Meta-attribute contains the name of the attribute which contains numeric value
of exception object.  This attribute will be used for representing exception
in numeric context.
.Sp
.Vb 4
\&  use Exception::Base \*(AqException::My\*(Aq => {
\&      has => \*(Aqmyattr\*(Aq,
\&      numeric_attribute => \*(Aqmyattr\*(Aq,
\&  };
\&
\&  eval { Exception::My\->throw(myattr=>123) };
\&  print 0 + $@;    # 123
.Ve
.IP "eval_attribute (default: 'message')" 4
.IX Item "eval_attribute (default: 'message')"
Meta-attribute contains the name of the attribute which is filled if error
stack is empty.  This attribute will contain value of \f(CW$@\fR variable.  This
attribute has meaning for derived classes.
.Sp
.Vb 4
\&  use Exception::Base \*(AqException::My\*(Aq => {
\&      has => \*(Aqmyattr\*(Aq,
\&      eval_attribute => \*(Aqmyattr\*(Aq
\&  };
\&
\&  eval { die "string" };
\&  print $@\->myattr;    # "string"
.Ve
.IP "string_attributes (default: ['message'])" 4
.IX Item "string_attributes (default: ['message'])"
Meta-attribute contains the array of names of attributes with defined value
which are joined to the string returned by \f(CW\*(C`to_string\*(C'\fR method.  If none of
attributes are defined, the string is created from the first default value of
attributes listed in the opposite order.
.Sp
.Vb 5
\&  use Exception::Base \*(AqException::My\*(Aq => {
\&      has => \*(Aqmyattr\*(Aq,
\&      myattr => \*(Aqdefault\*(Aq,
\&      string_attributes => [\*(Aqmessage\*(Aq, \*(Aqmyattr\*(Aq],
\&  };
\&
\&  eval { Exception::My\->throw( message=>"string", myattr=>"foo" ) };
\&  print $@\->myattr;    # "string: foo"
\&
\&  eval { Exception::My\->throw() };
\&  print $@\->myattr;    # "default"
.Ve
.SH "IMPORTS"
.IX Header "IMPORTS"
.ie n .IP """use Exception::Base \*(Aq\fIattribute\f(CW\*(Aq ="" \fIvalue\fR;>" 4
.el .IP "\f(CWuse Exception::Base \*(Aq\f(CIattribute\f(CW\*(Aq =\fR \fIvalue\fR;>" 4
.IX Item "use Exception::Base attribute = value;>"
Changes the default value for \fIattribute\fR.  If the \fIattribute\fR name has no
special prefix, its default value is replaced with a new \fIvalue\fR.
.Sp
.Vb 1
\&  use Exception::Base verbosity => 4;
.Ve
.Sp
If the \fIattribute\fR name starts with "\f(CW\*(C`+\*(C'\fR\*(L" or \*(R"\f(CW\*(C`\-\*(C'\fR" then the new \fIvalue\fR
is based on previous value:
.RS 4
.IP "\(bu" 4
If the original \fIvalue\fR was a reference to array, the new \fIvalue\fR can
be included or removed from original array.  Use array reference if you
need to add or remove more than one element.
.Sp
.Vb 3
\&  use Exception::Base
\&      "+ignore_packages" => [ _\|_PACKAGE_\|_, qr/^Moose::/ ],
\&      "\-ignore_class" => "My::Good::Class";
.Ve
.IP "\(bu" 4
If the original \fIvalue\fR was a number, it will be incremented or
decremented by the new \fIvalue\fR.
.Sp
.Vb 1
\&  use Exception::Base "+ignore_level" => 1;
.Ve
.IP "\(bu" 4
If the original \fIvalue\fR was a string, the new \fIvalue\fR will be
included.
.Sp
.Vb 1
\&  use Exception::Base "+message" => ": The incuded message";
.Ve
.RE
.RS 4
.RE
.ie n .IP """use Exception::Base \*(Aq\f(CIException\f(CW\*(Aq, ...;""" 4
.el .IP "\f(CWuse Exception::Base \*(Aq\f(CIException\f(CW\*(Aq, ...;\fR" 4
.IX Item "use Exception::Base Exception, ...;"
Loads additional exception class module.  If the module is not available,
creates the exception class automatically at compile time.  The newly created
class will be based on \f(CW\*(C`Exception::Base\*(C'\fR class.
.Sp
.Vb 2
\&  use Exception::Base qw{ Exception::Custom Exception::SomethingWrong };
\&  Exception::Custom\->throw;
.Ve
.ie n .IP """use Exception::Base \*(Aq\fIException\f(CW\*(Aq ="" { isa => \fIBaseException\fR, version => \fIversion\fR, ... };>" 4
.el .IP "\f(CWuse Exception::Base \*(Aq\f(CIException\f(CW\*(Aq =\fR { isa => \fIBaseException\fR, version => \fIversion\fR, ... };>" 4
.IX Item "use Exception::Base Exception = { isa => BaseException, version => version, ... };>"
Loads additional exception class module.  If the module's version is lower
than given parameter or the module can't be loaded, creates the exception
class automatically at compile time.  The newly created class will be based on
given class and has the given \f(CW$VERSION\fR variable.
.RS 4
.IP "isa" 4
.IX Item "isa"
The newly created class will be based on given class.
.Sp
.Vb 3
\&  use Exception::Base
\&    \*(AqException::My\*(Aq,
\&    \*(AqException::Nested\*(Aq => { isa => \*(AqException::My };
.Ve
.IP "version" 4
.IX Item "version"
The class will be created only if the module's version is lower than given
parameter and will have the version given in the argument.
.Sp
.Vb 2
\&  use Exception::Base
\&    \*(AqException::My\*(Aq => { version => 1.23 };
.Ve
.IP "has" 4
.IX Item "has"
The class will contain new rw attibute (if parameter is a string) or new rw
attributes (if parameter is a reference to array of strings) or new rw or ro
attributes (if parameter is a reference to hash of array of strings with rw
and ro as hash key).
.Sp
.Vb 7
\&  use Exception::Base
\&    \*(AqException::Simple\*(Aq => { has => \*(Aqfield\*(Aq },
\&    \*(AqException::More\*(Aq => { has => [ \*(Aqfield1\*(Aq, \*(Aqfield2\*(Aq ] },
\&    \*(AqException::Advanced\*(Aq => { has => {
\&        ro => [ \*(Aqfield1\*(Aq, \*(Aqfield2\*(Aq ],
\&        rw => [ \*(Aqfield3\*(Aq ]
\&    } };
.Ve
.IP "message" 4
.IX Item "message"
.PD 0
.IP "verbosity" 4
.IX Item "verbosity"
.IP "max_arg_len" 4
.IX Item "max_arg_len"
.IP "max_arg_nums" 4
.IX Item "max_arg_nums"
.IP "max_eval_len" 4
.IX Item "max_eval_len"
.IP "\fIother attribute having default property\fR" 4
.IX Item "other attribute having default property"
.PD
The class will have the default property for the given attribute.
.RE
.RS 4
.Sp
.Vb 5
\&  use Exception::Base
\&    \*(AqException::WithDefault\*(Aq => { message => \*(AqDefault message\*(Aq },
\&    \*(AqException::Reason\*(Aq => {
\&        has => [ \*(Aqreason\*(Aq ],
\&        string_attributes => [ \*(Aqmessage\*(Aq, \*(Aqreason\*(Aq ] };
.Ve
.RE
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "new([%\fIargs\fR])" 4
.IX Item "new([%args])"
Creates the exception object, which can be thrown later.  The system data
attributes like \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`pid\*(C'\fR, \f(CW\*(C`uid\*(C'\fR, \f(CW\*(C`gid\*(C'\fR, \f(CW\*(C`euid\*(C'\fR, \f(CW\*(C`egid\*(C'\fR are not
filled.
.Sp
If the key of the argument is read-write attribute, this attribute will be
filled. Otherwise, the argument will be ignored.
.Sp
.Vb 5
\&  $e = Exception::Base\->new(
\&           message=>"Houston, we have a problem",
\&           unknown_attr => "BIG"
\&       );
\&  print $e\->{message};
.Ve
.Sp
The constructor reads the list of class attributes from \s-1ATTRS\s0 constant
function and stores it in the internal cache for performance reason.  The
defaults values for the class are also stored in internal cache.
.ie n .IP """CLASS""\->throw([%\fIargs\fR]])" 4
.el .IP "\f(CWCLASS\fR\->throw([%\fIargs\fR]])" 4
.IX Item "CLASS->throw([%args]])"
Creates the exception object and immediately throws it with \f(CW\*(C`die\*(C'\fR system
function.
.Sp
.Vb 2
\&  open my $fh, $file
\&    or Exception::Base\->throw( message=>"Can not open file: $file" );
.Ve
.Sp
The \f(CW\*(C`throw\*(C'\fR is also exported as a function.
.Sp
.Vb 2
\&  open my $fh, $file
\&    or throw \*(AqException::Base\*(Aq => message=>"Can not open file: $file";
.Ve
.PP
The \f(CW\*(C`throw\*(C'\fR can be also used as a method.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$obj\->throw([%\fIargs\fR])" 4
.el .IP "\f(CW$obj\fR\->throw([%\fIargs\fR])" 4
.IX Item "$obj->throw([%args])"
Immediately throws exception object.  It can be used for rethrowing existing
exception object.  Additional arguments will override the attributes in
existing exception object.
.Sp
.Vb 3
\&  $e = Exception::Base\->new;
\&  # (...)
\&  $e\->throw( message=>"thrown exception with overridden message" );
\&
\&  eval { Exception::Base\->throw( message=>"Problem", value=>1 ) };
\&  $@\->throw if $@\->value;
.Ve
.ie n .IP "$obj\->throw(\fImessage\fR, [%\fIargs\fR])" 4
.el .IP "\f(CW$obj\fR\->throw(\fImessage\fR, [%\fIargs\fR])" 4
.IX Item "$obj->throw(message, [%args])"
If the number of \fIargs\fR list for arguments is odd, the first argument is a
message.  This message can be overridden by message from \fIargs\fR list.
.Sp
.Vb 3
\&  Exception::Base\->throw( "Problem", message=>"More important" );
\&  eval { die "Bum!" };
\&  Exception::Base\->throw( $@, message=>"New message" );
.Ve
.IP "\fI\s-1CLASS\s0\fR\->throw($\fIexception\fR, [%\fIargs\fR])" 4
.IX Item "CLASS->throw($exception, [%args])"
Immediately rethrows an existing exception object as an other exception class.
.Sp
.Vb 3
\&  eval { open $f, "w", "/etc/passwd" or Exception::System\->throw };
\&  # convert Exception::System into Exception::Base
\&  Exception::Base\->throw($@);
.Ve
.IP "\fI\s-1CLASS\s0\fR\->catch([$\fIvariable\fR])" 4
.IX Item "CLASS->catch([$variable])"
The exception is recovered from \fIvariable\fR argument or \f(CW$@\fR variable if
\&\fIvariable\fR argument was empty.  Then also \f(CW$@\fR is replaced with empty string
to avoid an endless loop.
.Sp
The method returns an exception object if exception is caught or undefined
value otherwise.
.Sp
.Vb 5
\&  eval { Exception::Base\->throw; };
\&  if ($@) {
\&      my $e = Exception::Base\->catch;
\&      print $e\->to_string;
\&  }
.Ve
.Sp
If the value is not empty and does not contain the \f(CW\*(C`Exception::Base\*(C'\fR object,
new exception object is created with class \fI\s-1CLASS\s0\fR and its message is based
on previous value with removed \f(CW" at file line 123."\fR string and the last end
of line (\s-1LF\s0).
.Sp
.Vb 3
\&  eval { die "Died\en"; };
\&  my $e = Exception::Base\->catch;
\&  print ref $e;   # "Exception::Base"
.Ve
.IP "matches(\fIthat\fR)" 4
.IX Item "matches(that)"
Checks if the exception object matches the given argument.
.Sp
The \f(CW\*(C`matches\*(C'\fR method overloads \f(CW\*(C`~~\*(C'\fR smart matching operator.  Warning: The
second argument for smart matching operator needs to be scalar.
.Sp
If the argument is a reference to array, it is checked if the object is a
given class.
.Sp
.Vb 7
\&  use Exception::Base
\&    \*(AqException::Simple\*(Aq,
\&    \*(AqException::Complex\*(Aq => { isa => \*(AqException::Simple };
\&  eval { Exception::Complex\->throw() };
\&  print $@\->matches( [\*(AqException::Base\*(Aq] );                    # matches
\&  print $@\->matches( [\*(AqException::Simple\*(Aq, \*(AqException::X\*(Aq] );  # matches
\&  print $@\->matches( [\*(AqNullObject\*(Aq] );                         # doesn\*(Aqt
.Ve
.Sp
If the argument is a reference to hash, attributes of the exception
object is matched.
.Sp
.Vb 4
\&  eval { Exception::Base\->throw( message=>"Message", value=>123 ) };
\&  print $@\->matches( { message=>"Message" } );             # matches
\&  print $@\->matches( { value=>123 } );                     # matches
\&  print $@\->matches( { message=>"Message", value=>45 } );  # doesn\*(Aqt
.Ve
.Sp
If the argument is a single string, regexp or code reference or is undefined,
the default attribute of the exception object is matched (usually it is a
\&\*(L"message\*(R" attribute).
.Sp
.Vb 7
\&  eval { Exception::Base\->throw( message=>"Message" ) };
\&  print $@\->matches( "Message" );                          # matches
\&  print $@\->matches( qr/Message/ );                        # matches
\&  print $@\->matches( qr/[0\-9]/ );                          # doesn\*(Aqt
\&  print $@\->matches( sub{/Message/} );                     # matches
\&  print $@\->matches( sub{0} );                             # doesn\*(Aqt
\&  print $@\->matches( undef );                              # doesn\*(Aqt
.Ve
.Sp
If argument is a numeric value, the argument matches if \f(CW\*(C`value\*(C'\fR attribute
matches.
.Sp
.Vb 3
\&  eval { Exception::Base\->throw( value=>123, message=>456 ) } );
\&  print $@\->matches( 123 );                                # matches
\&  print $@\->matches( 456 );                                # doesn\*(Aqt
.Ve
.Sp
If an attribute contains array reference, the array will be \f(CW\*(C`sprintf\*(C'\fR\-ed
before matching.
.Sp
.Vb 4
\&  eval { Exception::Base\->throw( message=>["%s", "Message"] ) };
\&  print $@\->matches( "Message" );                          # matches
\&  print $@\->matches( qr/Message/ );                        # matches
\&  print $@\->matches( qr/[0\-9]/ );                          # doesn\*(Aqt
.Ve
.Sp
The \f(CW\*(C`match\*(C'\fR method matches for special keywords:
.RS 4
.IP "\-isa" 4
.IX Item "-isa"
Matches if the object is a given class.
.Sp
.Vb 3
\&  eval { Exception::Base\->new( message=>"Message" ) };
\&  print $@\->matches( { \-isa=>"Exception::Base" } );            # matches
\&  print $@\->matches( { \-isa=>["X::Y", "Exception::Base"] } );  # matches
.Ve
.IP "\-has" 4
.IX Item "-has"
Matches if the object has a given attribute.
.Sp
.Vb 2
\&  eval { Exception::Base\->new( message=>"Message" ) };
\&  print $@\->matches( { \-has=>"Message" } );                    # matches
.Ve
.IP "\-default" 4
.IX Item "-default"
Matches against the default attribute, usually the \f(CW\*(C`message\*(C'\fR attribute.
.Sp
.Vb 2
\&  eval { Exception::Base\->new( message=>"Message" ) };
\&  print $@\->matches( { \-default=>"Message" } );                # matches
.Ve
.RE
.RS 4
.RE
.IP "to_string" 4
.IX Item "to_string"
Returns the string representation of exception object.  It is called
automatically if the exception object is used in string scalar context.  The
method can be used explicitly.
.Sp
.Vb 5
\&  eval { Exception::Base\->throw; };
\&  $@\->{verbosity} = 1;
\&  print "$@";
\&  $@\->verbosity = 4;
\&  print $@\->to_string;
.Ve
.IP "to_number" 4
.IX Item "to_number"
Returns the numeric representation of exception object.  It is called
automatically if the exception object is used in numeric scalar context.  The
method can be used explicitly.
.Sp
.Vb 3
\&  eval { Exception::Base\->throw( value => 42 ); };
\&  print 0+$@;           # 42
\&  print $@\->to_number;  # 42
.Ve
.IP "to_bool" 4
.IX Item "to_bool"
Returns the boolean representation of exception object.  It is called
automatically if the exception object is used in boolean context.  The method
can be used explicitly.
.Sp
.Vb 3
\&  eval { Exception::Base\->throw; };
\&  print "ok" if $@;           # ok
\&  print "ok" if $@\->to_bool;  # ok
.Ve
.IP "get_caller_stacktrace" 4
.IX Item "get_caller_stacktrace"
Returns an array of strings or string with caller stack trace.  It is
implicitly used by \f(CW\*(C`to_string\*(C'\fR method.
.IP "\s-1PROPAGATE\s0" 4
.IX Item "PROPAGATE"
Checks the caller stack and fills the \f(CW\*(C`propagated_stack\*(C'\fR attribute.  It is
usually used if \f(CW\*(C`die\*(C'\fR system function was called without any arguments.
.IP "_collect_system_data" 4
.IX Item "_collect_system_data"
Collects system data and fills the attributes of exception object.  This
method is called automatically if exception if thrown or created by
\&\f(CW\*(C`new\*(C'\fR constructor.  It can be overridden by derived class.
.Sp
.Vb 10
\&  package Exception::Special;
\&  use base \*(AqException::Base\*(Aq;
\&  use constant ATTRS => {
\&    %{Exception::Base\->ATTRS},
\&    \*(Aqspecial\*(Aq => { is => \*(Aqro\*(Aq },
\&  };
\&  sub _collect_system_data {
\&    my $self = shift;
\&    $self\->SUPER::_collect_system_data(@_);
\&    $self\->{special} = get_special_value();
\&    return $self;
\&  }
\&  BEGIN {
\&    _\|_PACKAGE_\|_\->_make_accessors;
\&  }
\&  1;
.Ve
.Sp
Method returns the reference to the self object.
.IP "_make_accessors" 4
.IX Item "_make_accessors"
Creates accessors for each attribute.  This static method should be called in
each derived class which defines new attributes.
.Sp
.Vb 5
\&  package Exception::My;
\&  # (...)
\&  BEGIN {
\&    _\|_PACKAGE_\|_\->_make_accessors;
\&  }
.Ve
.IP "package" 4
.IX Item "package"
Returns the package name of the subroutine which thrown an exception.
.IP "file" 4
.IX Item "file"
Returns the file name of the subroutine which thrown an exception.
.IP "line" 4
.IX Item "line"
Returns the line number for file of the subroutine which thrown an exception.
.IP "subroutine" 4
.IX Item "subroutine"
Returns the subroutine name which thrown an exception.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Repository: http://github.com/dex4er/perl\-Exception\-Base <http://github.com/dex4er/perl-Exception-Base>
.PP
There are more implementation of exception objects available on \s-1CPAN\s0.  Please
note that Perl has built-in implementation of pseudo-exceptions:
.PP
.Vb 6
\&  eval { die { message => "Pseudo\-exception", package => _\|_PACKAGE_\|_,
\&               file => _\|_FILE_\|_, line => _\|_LINE_\|_ };
\&  };
\&  if ($@) {
\&    print $@\->{message}, " at ", $@\->{file}, " in line ", $@\->{line}, ".\en";
\&  }
.Ve
.PP
The more complex implementation of exception mechanism provides more features.
.IP "Error" 4
.IX Item "Error"
Complete implementation of try/catch/finally/otherwise mechanism.  Uses nested
closures with a lot of syntactic sugar.  It is slightly faster than
\&\f(CW\*(C`Exception::Base\*(C'\fR module for failure scenario and is much slower for success
scenario.  It doesn't provide a simple way to create user defined exceptions.
It doesn't collect system data and stack trace on error.
.IP "Exception::Class" 4
.IX Item "Exception::Class"
More perl-ish way to do \s-1OO\s0 exceptions.  It is similar to \f(CW\*(C`Exception::Base\*(C'\fR
module and provides similar features but it is 10x slower for failure
scenario.
.IP "Exception::Class::TryCatch" 4
.IX Item "Exception::Class::TryCatch"
Additional try/catch mechanism for Exception::Class.  It is 15x slower for
success scenario.
.IP "Class::Throwable" 4
.IX Item "Class::Throwable"
Elegant \s-1OO\s0 exceptions similar to Exception::Class and \f(CW\*(C`Exception::Base\*(C'\fR.
It might be missing some features found in \f(CW\*(C`Exception::Base\*(C'\fR and
Exception::Class.
.IP "Exceptions" 4
.IX Item "Exceptions"
Not recommended.  Abadoned.  Modifies \f(CW%SIG\fR handlers.
.IP "TryCatch" 4
.IX Item "TryCatch"
A module which gives new try/catch keywords without source filter.
.IP "Try::Tiny" 4
.IX Item "Try::Tiny"
Smaller, simpler and slower version of TryCatch module.
.PP
The \f(CW\*(C`Exception::Base\*(C'\fR does not depend on other modules like
Exception::Class and it is more powerful than Class::Throwable.  Also it
does not use closures as Error and does not pollute namespace as
Exception::Class::TryCatch.  It is also much faster than
Exception::Class::TryCatch and Error for success scenario.
.PP
The \f(CW\*(C`Exception::Base\*(C'\fR is compatible with syntax sugar modules like
TryCatch and Try::Tiny.
.PP
The \f(CW\*(C`Exception::Base\*(C'\fR is also a base class for enhanced classes:
.IP "Exception::System" 4
.IX Item "Exception::System"
The exception class for system or library calls which modifies \f(CW$!\fR variable.
.IP "Exception::Died" 4
.IX Item "Exception::Died"
The exception class for eval blocks with simple \*(L"die\*(R" in perlfunc.  It can also
handle \f(CW$SIG\fR{_\|_DIE_\|_} hook and convert simple \*(L"die\*(R" in perlfunc
into an exception object.
.IP "Exception::Warning" 4
.IX Item "Exception::Warning"
The exception class which handle \f(CW$SIG\fR{_\|_WARN_\|_} hook and
convert simple \*(L"warn\*(R" in perlfunc into an exception object.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "New exception classes"
.IX Subsection "New exception classes"
The \f(CW\*(C`Exception::Base\*(C'\fR module allows to create new exception classes easly.
You can use \*(L"import\*(R" in perlfunc interface or base module to do it.
.PP
The \*(L"import\*(R" in perlfunc interface allows to create new class with new
read-write attributes.
.PP
.Vb 5
\&  package Exception::Simple;
\&  use Exception::Base (_\|_PACKAGE_\|_) => {
\&    has => qw{ reason method },
\&    string_attributes => qw{ message reason method },
\&  };
.Ve
.PP
For more complex exceptions you can redefine \f(CW\*(C`ATTRS\*(C'\fR constant.
.PP
.Vb 10
\&  package Exception::Complex;
\&  use base \*(AqException::Base\*(Aq;
\&  use constant ATTRS => {
\&    %{ Exception::Base\->ATTRS },     # SUPER::ATTRS
\&    hostname => { is => \*(Aqro\*(Aq },
\&    string_attributes => qw{ hostname message },
\&  };
\&  sub _collect_system_data {
\&    my $self = shift;
\&    my $hostname = \`hostname\`;
\&    chomp $hostname;
\&    $self\->{hostname} = $hostname;
\&    return $self\->SUPER::_collect_system_data(@_);
\&  }
.Ve
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
There are two scenarios for \*(L"eval\*(R" in perlfunc block: success or failure.
Success scenario should have no penalty on speed.  Failure scenario is usually
more complex to handle and can be significally slower.
.PP
Any other code than simple \f(CW\*(C`if ($@)\*(C'\fR is really slow and shouldn't be used if
speed is important.  It means that any module which provides try/catch syntax
sugar should be avoided: Error, Exception::Class::TryCatch, TryCatch,
Try::Tiny.  Be careful because simple \f(CW\*(C`if ($@)\*(C'\fR has many gotchas which are
described in Try::Tiny's documentation.
.PP
The \f(CW\*(C`Exception::Base\*(C'\fR module was benchmarked with other implementations for
simple try/catch scenario.  The results
(Perl 5.10.1 x86_64\-linux\-thread\-multi) are following:
.PP
.Vb 10
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Module                              | Success sub/s | Failure sub/s |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | eval/die string                     |       3715708 |        408951 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | eval/die object                     |       4563524 |        191664 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Exception::Base eval/if             |       4903857 |         11291 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Exception::Base eval/if verbosity=1 |       4790762 |         18833 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Error                               |        117475 |         26694 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Class::Throwable                    |       4618545 |         12678 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Exception::Class                    |        643901 |          3493 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Exception::Class::TryCatch          |        307825 |          3439 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | TryCatch                            |        690784 |        294802 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | Try::Tiny                           |        268780 |        158383 |
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
The \f(CW\*(C`Exception::Base\*(C'\fR module was written to be as fast as it is
possible.  It does not use internally i.e. accessor functions which are
slower about 6 times than standard variables.  It is slower than pure
die/eval for success scenario because it is uses \s-1OO\s0 mechanisms which are slow
in Perl.  It can be a little faster if some features are disables, i.e. the
stack trace and higher verbosity.
.PP
You can find the benchmark script in this package distribution.
.SH "BUGS"
.IX Header "BUGS"
If you find the bug or want to implement new features, please report it at
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Exception\-Base <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Exception-Base>
.SH "AUTHOR"
.IX Header "AUTHOR"
Piotr Roszatycki <dexter@cpan.org>
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2007, 2008, 2009, 2010 Piotr Roszatycki <dexter@cpan.org>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://dev.perl.org/licenses/artistic.html>
