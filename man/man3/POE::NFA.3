.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POE::NFA 3"
.TH POE::NFA 3 "2010-11-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::NFA \- an event\-driven state machine (nondeterministic finite automaton)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use POE::Kernel;
\&  use POE::NFA;
\&  use POE::Wheel::ReadLine;
\&
\&  # Spawn an NFA and enter its initial state.
\&  POE::NFA\->spawn(
\&    inline_states => {
\&      initial => {
\&        setup => \e&setup_stuff,
\&      },
\&      state_login => {
\&        on_entry => \e&login_prompt,
\&        on_input => \e&save_login,
\&      },
\&      state_password => {
\&        on_entry => \e&password_prompt,
\&        on_input => \e&check_password,
\&      },
\&      state_cmd => {
\&        on_entry => \e&command_prompt,
\&        on_input => \e&handle_command,
\&      },
\&    },
\&  )\->goto_state(initial => "setup");
\&
\&  POE::Kernel\->run();
\&  exit;
\&
\&  sub setup_stuff {
\&    $_[RUNSTATE]{io} = POE::Wheel::ReadLine\->new(
\&      InputEvent => \*(Aqon_input\*(Aq,
\&    );
\&    $_[MACHINE]\->goto_state(state_login => "on_entry");
\&  }
\&
\&  sub login_prompt { $_[RUNSTATE]{io}\->get(\*(AqLogin: \*(Aq); }
\&
\&  sub save_login {
\&    $_[RUNSTATE]{login} = $_[ARG0];
\&    $_[MACHINE]\->goto_state(state_password => "on_entry");
\&  }
\&
\&  sub password_prompt { $_[RUNSTATE]{io}\->get(\*(AqPassword: \*(Aq); }
\&
\&  sub check_password {
\&    if ($_[RUNSTATE]{login} eq $_[ARG0]) {
\&      $_[MACHINE]\->goto_state(state_cmd => "on_entry");
\&    }
\&    else {
\&      $_[MACHINE]\->goto_state(state_login => "on_entry");
\&    }
\&  }
\&
\&  sub command_prompt { $_[RUNSTATE]{io}\->get(\*(AqCmd: \*(Aq); }
\&
\&  sub handle_command {
\&    $_[RUNSTATE]{io}\->put("  <<$_[ARG0]>>");
\&    if ($_[ARG0] =~ /^(?:quit|stop|exit|halt|bye)$/i) {
\&      $_[RUNSTATE]{io}\->put(\*(AqBye!\*(Aq);
\&      $_[MACHINE]\->stop();
\&    }
\&    else {
\&      $_[MACHINE]\->goto_state(state_cmd => "on_entry");
\&    }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1POE::NFA\s0 implements a different kind of \s-1POE\s0 session: A
non-deterministic finite automaton.  Let's break that down.
.PP
A finite automaton is a state machine with a bounded number of states
and transitions.  Technically, \s-1POE::NFA\s0 objects may modify themselves
at run time, so they aren't really \*(L"finite\*(R".  Run-time modification
isn't currently supported by the \s-1API\s0, so plausible deniability is
maintained!
.PP
Deterministic state machines are ones where all possible transitions
are known at compile time.  \s-1POE::NFA\s0 is \*(L"non-deterministic\*(R" because
transitions may change based on run-time conditions.
.PP
But more simply, \s-1POE::NFA\s0 is like POE::Session but with banks of event
handlers that may be swapped according to the session's run-time state.
Consider the \s-1SYNOPSIS\s0 example, which has \*(L"on_entry\*(R" and \*(L"on_input\*(R"
handlers that do different things depending on the run-time state.
POE::Wheel::ReadLine throws \*(L"on_input\*(R", but different things happen
depending whether the session is in its \*(L"login\*(R", \*(L"password\*(R" or
\&\*(L"command\*(R" state.
.PP
\&\s-1POE::NFA\s0 borrows heavily from POE::Session, so this document will only
discuss the differences.  Please see POE::Session for things which
are similar.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
This document mainly focuses on the differences from POE::Session.
.SS "get_current_state"
.IX Subsection "get_current_state"
Each machine state has a name.  \fIget_current_state()\fR returns the name
of the machine's current state.  \fIget_current_state()\fR is mainly used to
retrieve the state of some other machine.  It's easier (and faster) to
use \f(CW$_[STATE]\fR in a machine's own event handlers.
.SS "get_runstate"
.IX Subsection "get_runstate"
\&\fIget_runstate()\fR returns the machine's current runstate.  Runstates are
equivalent to POE::Session HEAPs, so this method does pretty much the
same as POE::Session's \fIget_heap()\fR.  It's easier (and faster) to use
\&\f(CW$_[RUNSTATE]\fR in a machine's own event handlers, however.
.SS "spawn \s-1STATE_NAME\s0 => HANDLERS_HASHREF[, ...]"
.IX Subsection "spawn STATE_NAME => HANDLERS_HASHREF[, ...]"
\&\fIspawn()\fR is \s-1POE::NFA\s0's constructor.  The name reflects the idea that
new state machines are spawned like threads or processes rather than
instantiated like objects.
.PP
The machine itself is defined as a list of state names and hashes that
map events to handlers within each state.
.PP
.Vb 10
\&  my %states = (
\&    state_1 => {
\&      event_1 => \e&handler_1,
\&      event_2 => \e&handler_2,
\&    },
\&    state_2 => {
\&      event_1 => \e&handler_3,
\&      event_2 => \e&handler_4,
\&    },
\&  );
.Ve
.PP
A single event may be handled by many states.  The proper handler will
be called depending on the machine's current state.  For example, if
\&\f(CW\*(C`event_1\*(C'\fR is dispatched while the machine is in \f(CW\*(C`state_2\*(C'\fR, then
\&\fIhandler_3()\fR will be called to handle the event.  The state \-> event \->
handler map looks like this:
.PP
.Vb 1
\&  $machine{state_2}{event_1} = \e&handler_3;
.Ve
.PP
Instead of \f(CW\*(C`inline_states\*(C'\fR, \f(CW\*(C`object_states\*(C'\fR or \f(CW\*(C`package_states\*(C'\fR may
be used. These map the events of a state to an object or package method
respectively.
.PP
.Vb 11
\&  object_states => {
\&    state_1 => [
\&      $object_1 => [qw(event_1 event_2)],
\&    ],
\&    state_2 => [
\&      $object_2 => {
\&        event_1 => method_1,
\&        event_2 => method_2,
\&      }
\&    ]
\&  }
.Ve
.PP
In the example above, in the case of \f(CW\*(C`event_1\*(C'\fR coming in while the machine
is in \f(CW\*(C`state_1\*(C'\fR, method \f(CW\*(C`event_1\*(C'\fR will be called on \f(CW$object_1\fR. If the
machine is in \f(CW\*(C`state_2\*(C'\fR, method \f(CW\*(C`method_1\*(C'\fR will be called on \f(CW$object_2\fR.
.PP
\&\f(CW\*(C`package_states\*(C'\fR is very similar, but instead of using an \f(CW$object\fR, you
pass in a \f(CW\*(C`Package::Name\*(C'\fR
.PP
The \f(CW\*(C`runstate\*(C'\fR parameter allows \f(CW\*(C`RUNSTATE\*(C'\fR to be initialized differently 
at instantiation time. \f(CW\*(C`RUNSTATE\*(C'\fR, like heaps, are usually anonymous hashrefs, 
but \f(CW\*(C`runstate\*(C'\fR may set them to be array references or even objects.
.SS "goto_state NEW_STATE[, ENTRY_EVENT[, \s-1EVENT_ARGS\s0]]"
.IX Subsection "goto_state NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]"
\&\fIgoto_state()\fR puts the machine into a new state.  If an \s-1ENTRY_EVENT\s0 is
specified, then that event will be dispatched after the machine enters
the new state.  \s-1EVENT_ARGS\s0, if included, will be passed to the entry
event's handler via \f(CW\*(C`ARG0..$#_\*(C'\fR.
.PP
.Vb 2
\&  # Switch to the next state.
\&  $_[MACHINE]\->goto_state( \*(Aqnext_state\*(Aq );
\&
\&  # Switch to the next state, and call a specific entry point.
\&  $_[MACHINE]\->goto_state( \*(Aqnext_state\*(Aq, \*(Aqentry_event\*(Aq );
\&
\&  # Switch to the next state; call an entry point with some values.
\&  $_[MACHINE]\->goto_state( \*(Aqnext_state\*(Aq, \*(Aqentry_event\*(Aq, @parameters );
.Ve
.SS "stop"
.IX Subsection "stop"
\&\fIstop()\fR forces a machine to stop.  The machine will also stop
gracefully if it runs out of things to do, just like POE::Session.
.PP
\&\fIstop()\fR is heavy-handed.  It will force resources to be cleaned up.
However, circular references in the machine's \f(CW\*(C`RUNSTATE\*(C'\fR are not
\&\s-1POE\s0's responsibility and may cause memory leaks.
.PP
.Vb 1
\&  $_[MACHINE]\->stop();
.Ve
.SS "call_state \s-1RETURN_EVENT\s0, NEW_STATE[, ENTRY_EVENT[, \s-1EVENT_ARGS\s0]]"
.IX Subsection "call_state RETURN_EVENT, NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]"
\&\fIcall_state()\fR is similar to \fIgoto_state()\fR, but it pushes the current
state on a stack.  At some later point, a handler can call
\&\fIreturn_state()\fR to pop the call stack and return the machine to its old
state.  At that point, a \f(CW\*(C`RETURN_EVENT\*(C'\fR will be posted to notify the
old state of the return.
.PP
.Vb 1
\&  $machine\->call_state( \*(Aqreturn_here\*(Aq, \*(Aqnew_state\*(Aq, \*(Aqentry_event\*(Aq );
.Ve
.PP
As with \fIgoto_state()\fR, \f(CW\*(C`ENTRY_EVENT\*(C'\fR is the event that will be emitted
once the machine enters its new state.  \f(CW\*(C`ENTRY_ARGS\*(C'\fR are parameters
passed to the \f(CW\*(C`ENTRY_EVENT\*(C'\fR handler via \f(CW\*(C`ARG0..$#_\*(C'\fR.
.SS "return_state [\s-1RETURN_ARGS\s0]"
.IX Subsection "return_state [RETURN_ARGS]"
\&\fIreturn_state()\fR returns to the most recent state in which \fIcall_state()\fR
was invoked.  If the preceding \fIcall_state()\fR included a return event
then its handler will be invoked along with some optional
\&\f(CW\*(C`RETURN_ARGS\*(C'\fR.  The \f(CW\*(C`RETURN_ARGS\*(C'\fR will be passed to the return
handler via \f(CW\*(C`ARG0..$#_\*(C'\fR.
.PP
.Vb 1
\&  $_[MACHINE]\->return_state( \*(Aqsuccess\*(Aq, @success_values );
.Ve
.SS "Methods that match POE::Session"
.IX Subsection "Methods that match POE::Session"
The following methods behave identically to the ones in POE::Session.
.IP "\s-1ID\s0" 2
.IX Item "ID"
.PD 0
.IP "option" 2
.IX Item "option"
.IP "postback" 2
.IX Item "postback"
.IP "callback" 2
.IX Item "callback"
.PD
.SS "About \fInew()\fP and \fIcreate()\fP"
.IX Subsection "About new() and create()"
\&\s-1POE::NFA\s0's constructor is \fIspawn()\fR, not \fInew()\fR or \fIcreate()\fR.
.SH "PREDEFINED EVENT FIELDS"
.IX Header "PREDEFINED EVENT FIELDS"
\&\s-1POE::NFA\s0's predefined event fields are the same as POE::Session's with
the following three exceptions.
.SS "\s-1MACHINE\s0"
.IX Subsection "MACHINE"
\&\f(CW\*(C`MACHINE\*(C'\fR is equivalent to Session's \f(CW\*(C`SESSION\*(C'\fR field.  It holds a
reference to the current state machine, and is useful for calling
its methods.
.PP
See POE::Session's \f(CW\*(C`SESSION\*(C'\fR field for more information.
.PP
.Vb 1
\&  $_[MACHINE]\->goto_state( $next_state, $next_state_entry_event );
.Ve
.SS "\s-1RUNSTATE\s0"
.IX Subsection "RUNSTATE"
\&\f(CW\*(C`RUNSTATE\*(C'\fR is equivalent to Session's \f(CW\*(C`HEAP\*(C'\fR field.  It holds an
anonymous hash reference which \s-1POE\s0 is guaranteed not to touch.  Data
stored in \f(CW\*(C`RUNSTATE\*(C'\fR will persist between handler invocations.
.SS "\s-1STATE\s0"
.IX Subsection "STATE"
\&\f(CW\*(C`STATE\*(C'\fR contains the name of the machine's current state.  It is not
equivalent to anything from POE::Session.
.SS "\s-1EVENT\s0"
.IX Subsection "EVENT"
\&\f(CW\*(C`EVENT\*(C'\fR is equivalent to Session's \f(CW\*(C`STATE\*(C'\fR field.  It holds the name
of the event which invoked the current handler.  See POE::Session's
\&\f(CW\*(C`STATE\*(C'\fR field for more information.
.SH "PREDEFINED EVENT NAMES"
.IX Header "PREDEFINED EVENT NAMES"
\&\s-1POE::NFA\s0 defines four events of its own.  These events are used
internally and may not be overridden by application code.
.PP
See POE::Session's \*(L"\s-1PREDEFINED\s0 \s-1EVENT\s0 \s-1NAMES\s0\*(R" section for more
information about other predefined events.
.PP
The events are: \f(CW\*(C`poe_nfa_goto_state\*(C'\fR, \f(CW\*(C`poe_nfa_push_state\*(C'\fR,
\&\f(CW\*(C`poe_nfa_pop_state\*(C'\fR, \f(CW\*(C`poe_nfa_stop\*(C'\fR.
.PP
Yes, all the internal events begin with \*(L"poe_nfa_\*(R".  More may be
forthcoming, but they will always begin the same way.  Therefore
please do not define events beginning with \*(L"poe_nfa_\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Many of \s-1POE::NFA\s0's features are taken directly from POE::Session.
Please see POE::Session for more information.
.PP
The \s-1SEE\s0 \s-1ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.SH "BUGS"
.IX Header "BUGS"
See POE::Session's documentation.
.PP
\&\s-1POE::NFA\s0 is not as feature-complete as POE::Session.  Your feedback is
appreciated.
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
Please see \s-1POE\s0 for more information about authors and contributors.
