.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Dispatch::Output 3"
.TH Log::Dispatch::Output 3 "2010-12-13" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Dispatch::Output \- Base class for all Log::Dispatch::* objects
.SH "VERSION"
.IX Header "VERSION"
version 2.28
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Log::Dispatch::MySubclass;
\&
\&  use Log::Dispatch::Output;
\&  use base qw( Log::Dispatch::Output );
\&
\&  sub new {
\&      my $proto = shift;
\&      my $class = ref $proto || $proto;
\&
\&      my %p = @_;
\&
\&      my $self = bless {}, $class;
\&
\&      $self\->_basic_init(%p);
\&
\&      # Do more if you like
\&
\&      return $self;
\&  }
\&
\&  sub log_message {
\&      my $self = shift;
\&      my %p    = @_;
\&
\&      # Do something with message in $p{message}
\&  }
\&
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is the base class from which all Log::Dispatch::* objects
should be derived.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The constructor, \f(CW\*(C`new\*(C'\fR, must be overridden in a subclass. See Output
Classes for a description of the common
parameters accepted by this constructor.
.SH "METHODS"
.IX Header "METHODS"
.IP "\(bu" 4
_basic_init(%p)
.Sp
This should be called from a subclass's constructor.  Make sure to
pass the arguments in \f(CW@_\fR to it.  It sets the object's name and minimum
level.  It also sets up two other attributes which are used by other
Log::Dispatch::Output methods, level_names and level_numbers.
.IP "\(bu" 4
name
.Sp
Returns the object's name.
.IP "\(bu" 4
min_level
.Sp
Returns the object's minimum log level.
.IP "\(bu" 4
max_level
.Sp
Returns the object's maximum log level.
.IP "\(bu" 4
accepted_levels
.Sp
Returns a list of the object's accepted levels (by name) from minimum
to maximum.
.IP "\(bu" 4
log( level => $, message => $ )
.Sp
Sends a message if the level is greater than or equal to the object's
minimum level.  This method applies any message formatting callbacks
that the object may have.
.IP "\(bu" 4
_should_log ($)
.Sp
This method is called from the \f(CW\*(C`log()\*(C'\fR method with the log level of
the message to be logged as an argument.  It returns a boolean value
indicating whether or not the message should be logged by this
particular object.  The \f(CW\*(C`log()\*(C'\fR method will not process the message
if the return value is false.
.IP "\(bu" 4
_level_as_number ($)
.Sp
This method will take a log level as a string (or a number) and return
the number of that log level.  If not given an argument, it returns
the calling object's log level instead.  If it cannot determine the
level then it will croak.
.IP "\(bu" 4
add_callback( \f(CW$code\fR )
.Sp
Adds a callback (like those given during construction). It is added to the end
of the list of callbacks.
.SS "Subclassing"
.IX Subsection "Subclassing"
This class should be used as the base class for all logging objects
you create that you would like to work under the Log::Dispatch
architecture.  Subclassing is fairly trivial.  For most subclasses, if
you simply copy the code in the \s-1SYNOPSIS\s0 and then put some
functionality into the \f(CW\*(C`log_message\*(C'\fR method then you should be all
set.  Please make sure to use the \f(CW\*(C`_basic_init\*(C'\fR method as directed.
.PP
The actual logging implementation should be done in a \f(CW\*(C`log_message\*(C'\fR
method that you write. \fBDo not override \f(CB\*(C`log\*(C'\fB!\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2010 by Dave Rolsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0
.Ve
