.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Cmd::Tutorial 3"
.TH App::Cmd::Tutorial 3 "2010-12-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::Cmd::Tutorial \- getting started with App::Cmd
.SH "VERSION"
.IX Header "VERSION"
version 0.310
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
App::Cmd is a set of tools designed to make it simple to write sophisticated
command line programs.  It handles commands with multiple subcommands,
generates usage text, validates options, and lets you write your program as
easy-to-test classes.
.PP
An App::Cmd\-based application is made up of three main parts:  the script, the
application class, and the command classes.
.PP
The script is the actual executable file run at the command line.  It can
generally consist of just a few lines:
.PP
.Vb 3
\&  #!/usr/bin/perl
\&  use YourApp;
\&  YourApp\->run;
.Ve
.PP
All the work of argument parsing, validation, and dispatch is taken care of by
your application class.  The application class can also be pretty simple, and
might look like this:
.PP
.Vb 3
\&  package YourApp;
\&  use App::Cmd::Setup \-app;
\&  1;
.Ve
.PP
When a new application instance is created, it loads all of the command classes
it can find, looking for modules under the Command namespace under its own
name.  In the above snippet, for example, YourApp will look for any module with
a name starting with \f(CW\*(C`YourApp::Command::\*(C'\fR.
.PP
We can set up a simple command class like this:
.PP
.Vb 3
\&  package YourApp::Command::initialize;
\&  use YourApp \-command;
\&  1;
.Ve
.PP
Now, a user can run this command, but he'll get an error:
.PP
.Vb 2
\&  $ yourcmd initialize
\&  YourApp::Command::initialize does not implement mandatory method \*(Aqexecute\*(Aq
.Ve
.PP
Oops!  This dies because we haven't told the command class what it should do
when executed.  This is easy, we just add some code:
.PP
.Vb 2
\&  sub execute {
\&    my ($self, $opt, $args) = @_;
\&
\&    print "Everything has been initialized.  (Not really.)\en";
\&  }
.Ve
.PP
Now it works:
.PP
.Vb 2
\&  $ yourcmd initialize
\&  Everything has been initialized.  (Not really.)
.Ve
.PP
The arguments to the execute method are the parsed options from the command
line (that is, the switches) and the remaining arguments.  With a properly
configured command class, the following invocation:
.PP
.Vb 1
\&  $ yourcmd reset \-zB \-\-new\-seed xyzxy foo.db bar.db
.Ve
.PP
might result in the following data:
.PP
.Vb 5
\&  $opt = {
\&    zero      => 1,
\&    no_backup => 1,
\&    new_seed  => \*(Aqxyzzy\*(Aq,
\&  };
\&
\&  $args = [ qw(foo.db bar.db) ];
.Ve
.PP
Arguments are processed by Getopt::Long::Descriptive (\s-1GLD\s0).  To customize
its argument processing, a command class can implement a few methods:
\&\f(CW\*(C`usage_desc\*(C'\fR provides the usage format string; \f(CW\*(C`opt_spec\*(C'\fR provides the option
specification list; \f(CW\*(C`validate_args\*(C'\fR is run after Getopt::Long::Descriptive,
and is meant to validate the \f(CW$args\fR, which \s-1GLD\s0 ignores.
.PP
The first two methods provide configuration passed to \s-1GLD\s0's \f(CW\*(C`describe_options\*(C'\fR
routine.  To improve our command class, we might add the following code:
.PP
.Vb 1
\&  sub usage_desc { "yourcmd %o [dbfile ...]" }
\&
\&  sub opt_spec {
\&    return (
\&      [ "skip\-refs|R",  "skip reference checks during init", ],
\&      [ "values|v=s@",  "starting values", { default => [ 0, 1, 3 ] } ],
\&    );
\&  }
\&
\&  sub validate_args {
\&    my ($self, $opt, $args) = @_;
\&
\&    # we need at least one argument beyond the options; die with that message
\&    # and the complete "usage" text describing switches, etc
\&    $self\->usage_error("too few arguments") unless @$args;
\&  }
.Ve
.SH "TIPS"
.IX Header "TIPS"
.IP "\(bu" 4
Delay using large modules using autouse, Class::Autouse or \f(CW\*(C`require\*(C'\fR in
your commands to save memory and make startup faster. Since only one of these
commands will be run anyway, there's no need to preload the requirements for
all of them.
.IP "\(bu" 4
To add a \f(CW\*(C`\-\-help\*(C'\fR option to all your commands create a base class like:
.Sp
.Vb 2
\&  package MyApp::Command;
\&  use App::Cmd::Setup \-command;
\&
\&  sub opt_spec {
\&    my ( $class, $app ) = @_;
\&    return (
\&      [ \*(Aqhelp\*(Aq => "This usage screen" ],
\&      $class\->options($app),
\&    )
\&  }
\&
\&  sub validate_args {
\&    my ( $self, $opt, $args ) = @_;
\&    die $self\->_usage_text if $opt\->{help};
\&    $self\->validate( $opt, $args );
\&  }
.Ve
.Sp
Where \f(CW\*(C`options\*(C'\fR and \f(CW\*(C`validate\*(C'\fR are \*(L"inner\*(R" methods which your command
subclasses implement.
.IP "\(bu" 4
To let your users configure default values for options, put a sub like
.Sp
.Vb 4
\&  sub config {
\&    my $app = shift;
\&    $app\->{config} ||= TheLovelyConfigModule\->load_config_file();
\&  }
.Ve
.Sp
in your main app file, and then do something like:
.Sp
.Vb 9
\&  sub opt_spec {
\&    my ( $class, $app ) = @_;
\&    my ( $name ) = $class\->command_names;
\&    return (
\&      [ \*(Aqblort=s\*(Aq => "That special option",
\&        { default => $app\->config\->{$name}{blort} || $fallback_default },
\&      ],
\&    );
\&  }
.Ve
.Sp
Or better yet, put this logic in a superclass and process the return value from
an \*(L"inner\*(R" method (see previous tip for an example).
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
